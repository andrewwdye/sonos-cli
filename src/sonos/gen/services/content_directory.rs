// Generated by sonos-docs, do not edit.

use rupnp::{Device, Service};
use rupnp::http::Uri;
use rupnp::ssdp::URN;use crate::sonos::gen::errors::Error;
use serde_xml_rs;

/// Sonos ContentDirectoryService
///
/// Browse for local content
#[derive(Debug)]
pub struct ContentDirectoryService {
    service: Service,
    url: Uri,
}

impl ContentDirectoryService {
    /// Create a new ContentDirectoryService instance from an existing UPnP device.
    pub async fn from_device(device: Device) -> Option<Self> {
        let urn = "urn:schemas-upnp-org:service:ContentDirectory:1".parse::<URN>().unwrap();
        if let Some(s) = device.find_service(&urn) {
            Some(Self{ service: s.clone(), url: device.url().clone() })
        } else {
            None
        }
    }

    /// Browse
    ///
    /// Browse for content: Music library (A), share(S:), Sonos playlists(SQ:), Sonos favorites(FV:2), radio stations(R:0/0), radio shows(R:0/1), queue(Q:)). Recommendation: Send one request, check the `TotalMatches` and - if necessary - do additional requests with higher `StartingIndex`. In case of duplicates only the first is returned! Example: albums with same title, even if artists are different
    ///
    /// Note: (1) If the title contains an apostrophe the returned uri will contain a `&apos;`. (2) Some libraries support a BrowseAndParse, so you don't have to parse the xml.
    ///
    /// Parameters:
    /// * `object_id` : The search query, (`A:ARTIST` / `A:ALBUMARTIST` / `A:ALBUM` / `A:GENRE` / `A:COMPOSER` / `A:TRACKS` / `A:PLAYLISTS` / `FV:2` / `Q:`/ `R:0/0` / `R:0/1` / `S:` / `SQ:`) with optionally `:search+query` behind it.
    /// * `browse_flag` : How to browse
    /// * `filter` : Which fields should be returned `*` for all.
    /// * `starting_index` : Paging, where to start, usually 0
    /// * `requested_count` : Paging, number of items, maximum is 1,000. This parameter does NOT restrict the number of items being searched (filter) but only the number being returned. Using 0 is equivalent to 1,000
    /// * `sort_criteria` : Sort the results based on metadata fields. `+upnp:artist,+dc:title` for sorting on artist then on title.
    ///
    /// Outputs:
    /// * `result` : Encoded DIDL-Lite XML. See remark (2)
    /// * `number_returned`
    /// * `total_matches`
    /// * `update_id`
    pub async fn browse(
            &self,
            object_id: String,
            browse_flag: String,
            filter: String,
            starting_index: u32,
            requested_count: u32,
            sort_criteria: String
        ) -> Result<BrowseResult, Error> {
        let payload = [
            serde_xml_rs::to_string(&object_id).unwrap(),
            serde_xml_rs::to_string(&browse_flag).unwrap(),
            serde_xml_rs::to_string(&filter).unwrap(),
            serde_xml_rs::to_string(&starting_index).unwrap(),
            serde_xml_rs::to_string(&requested_count).unwrap(),
            serde_xml_rs::to_string(&sort_criteria).unwrap(),
        ].concat();
        let response = self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        // TODO: map parse errors
        Ok(BrowseResult {
            result: response.get("Result").ok_or_else(|| Error::MissingField("Result".to_string()))?
                .parse().map_err(|_| Error::ParseError("Result".to_string()))?,
            number_returned: response.get("NumberReturned").ok_or_else(|| Error::MissingField("NumberReturned".to_string()))?
                .parse().map_err(|_| Error::ParseError("NumberReturned".to_string()))?,
            total_matches: response.get("TotalMatches").ok_or_else(|| Error::MissingField("TotalMatches".to_string()))?
                .parse().map_err(|_| Error::ParseError("TotalMatches".to_string()))?,
            update_id: response.get("UpdateID").ok_or_else(|| Error::MissingField("UpdateID".to_string()))?
                .parse().map_err(|_| Error::ParseError("UpdateID".to_string()))?,
        })
    }

    /// CreateObject
    ///
    /// Parameters:
    /// * `container_id`
    /// * `elements`
    ///
    /// Outputs:
    /// * `object_id`
    /// * `result`
    pub async fn create_object(
            &self,
            container_id: String,
            elements: String
        ) -> Result<CreateObjectResult, Error> {
        let payload = [
            serde_xml_rs::to_string(&container_id).unwrap(),
            serde_xml_rs::to_string(&elements).unwrap(),
        ].concat();
        let response = self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        // TODO: map parse errors
        Ok(CreateObjectResult {
            object_id: response.get("ObjectID").ok_or_else(|| Error::MissingField("ObjectID".to_string()))?
                .parse().map_err(|_| Error::ParseError("ObjectID".to_string()))?,
            result: response.get("Result").ok_or_else(|| Error::MissingField("Result".to_string()))?
                .parse().map_err(|_| Error::ParseError("Result".to_string()))?,
        })
    }

    /// DestroyObject
    ///
    /// Parameters:
    /// * `object_id`
    pub async fn destroy_object(
            &self,
            object_id: String
        ) -> Result<(), Error> {
        let payload = [
            serde_xml_rs::to_string(&object_id).unwrap(),
        ].concat();
        self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        Ok(())
    }

    /// FindPrefix
    ///
    /// Parameters:
    /// * `object_id`
    /// * `prefix`
    ///
    /// Outputs:
    /// * `starting_index`
    /// * `update_id`
    pub async fn find_prefix(
            &self,
            object_id: String,
            prefix: String
        ) -> Result<FindPrefixResult, Error> {
        let payload = [
            serde_xml_rs::to_string(&object_id).unwrap(),
            serde_xml_rs::to_string(&prefix).unwrap(),
        ].concat();
        let response = self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        // TODO: map parse errors
        Ok(FindPrefixResult {
            starting_index: response.get("StartingIndex").ok_or_else(|| Error::MissingField("StartingIndex".to_string()))?
                .parse().map_err(|_| Error::ParseError("StartingIndex".to_string()))?,
            update_id: response.get("UpdateID").ok_or_else(|| Error::MissingField("UpdateID".to_string()))?
                .parse().map_err(|_| Error::ParseError("UpdateID".to_string()))?,
        })
    }

    /// GetAlbumArtistDisplayOption
    ///
    /// Get the current album art display option such as `WMP`, `ITUNES` or `NONE`
    ///
    /// Outputs:
    /// * `album_artist_display_option`
    pub async fn get_album_artist_display_option(
            &self,
        ) -> Result<GetAlbumArtistDisplayOptionResult, Error> {
        let payload = String::new();
        let response = self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        // TODO: map parse errors
        Ok(GetAlbumArtistDisplayOptionResult {
            album_artist_display_option: response.get("AlbumArtistDisplayOption").ok_or_else(|| Error::MissingField("AlbumArtistDisplayOption".to_string()))?
                .parse().map_err(|_| Error::ParseError("AlbumArtistDisplayOption".to_string()))?,
        })
    }

    /// GetAllPrefixLocations
    ///
    /// Parameters:
    /// * `object_id`
    ///
    /// Outputs:
    /// * `total_prefixes`
    /// * `prefix_and_index_csv`
    /// * `update_id`
    pub async fn get_all_prefix_locations(
            &self,
            object_id: String
        ) -> Result<GetAllPrefixLocationsResult, Error> {
        let payload = [
            serde_xml_rs::to_string(&object_id).unwrap(),
        ].concat();
        let response = self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        // TODO: map parse errors
        Ok(GetAllPrefixLocationsResult {
            total_prefixes: response.get("TotalPrefixes").ok_or_else(|| Error::MissingField("TotalPrefixes".to_string()))?
                .parse().map_err(|_| Error::ParseError("TotalPrefixes".to_string()))?,
            prefix_and_index_csv: response.get("PrefixAndIndexCSV").ok_or_else(|| Error::MissingField("PrefixAndIndexCSV".to_string()))?
                .parse().map_err(|_| Error::ParseError("PrefixAndIndexCSV".to_string()))?,
            update_id: response.get("UpdateID").ok_or_else(|| Error::MissingField("UpdateID".to_string()))?
                .parse().map_err(|_| Error::ParseError("UpdateID".to_string()))?,
        })
    }

    /// GetBrowseable
    ///
    /// Outputs:
    /// * `is_browseable`
    pub async fn get_browseable(
            &self,
        ) -> Result<GetBrowseableResult, Error> {
        let payload = String::new();
        let response = self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        // TODO: map parse errors
        Ok(GetBrowseableResult {
            is_browseable: response.get("IsBrowseable").ok_or_else(|| Error::MissingField("IsBrowseable".to_string()))?
                .parse().map_err(|_| Error::ParseError("IsBrowseable".to_string()))?,
        })
    }

    /// GetLastIndexChange
    ///
    /// Outputs:
    /// * `last_index_change`
    pub async fn get_last_index_change(
            &self,
        ) -> Result<GetLastIndexChangeResult, Error> {
        let payload = String::new();
        let response = self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        // TODO: map parse errors
        Ok(GetLastIndexChangeResult {
            last_index_change: response.get("LastIndexChange").ok_or_else(|| Error::MissingField("LastIndexChange".to_string()))?
                .parse().map_err(|_| Error::ParseError("LastIndexChange".to_string()))?,
        })
    }

    /// GetSearchCapabilities
    ///
    /// Outputs:
    /// * `search_caps`
    pub async fn get_search_capabilities(
            &self,
        ) -> Result<GetSearchCapabilitiesResult, Error> {
        let payload = String::new();
        let response = self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        // TODO: map parse errors
        Ok(GetSearchCapabilitiesResult {
            search_caps: response.get("SearchCaps").ok_or_else(|| Error::MissingField("SearchCaps".to_string()))?
                .parse().map_err(|_| Error::ParseError("SearchCaps".to_string()))?,
        })
    }

    /// GetShareIndexInProgress
    ///
    /// Outputs:
    /// * `is_indexing`
    pub async fn get_share_index_in_progress(
            &self,
        ) -> Result<GetShareIndexInProgressResult, Error> {
        let payload = String::new();
        let response = self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        // TODO: map parse errors
        Ok(GetShareIndexInProgressResult {
            is_indexing: response.get("IsIndexing").ok_or_else(|| Error::MissingField("IsIndexing".to_string()))?
                .parse().map_err(|_| Error::ParseError("IsIndexing".to_string()))?,
        })
    }

    /// GetSortCapabilities
    ///
    /// Outputs:
    /// * `sort_caps`
    pub async fn get_sort_capabilities(
            &self,
        ) -> Result<GetSortCapabilitiesResult, Error> {
        let payload = String::new();
        let response = self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        // TODO: map parse errors
        Ok(GetSortCapabilitiesResult {
            sort_caps: response.get("SortCaps").ok_or_else(|| Error::MissingField("SortCaps".to_string()))?
                .parse().map_err(|_| Error::ParseError("SortCaps".to_string()))?,
        })
    }

    /// GetSystemUpdateID
    ///
    /// Outputs:
    /// * `id`
    pub async fn get_system_update_id(
            &self,
        ) -> Result<GetSystemUpdateIDResult, Error> {
        let payload = String::new();
        let response = self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        // TODO: map parse errors
        Ok(GetSystemUpdateIDResult {
            id: response.get("Id").ok_or_else(|| Error::MissingField("Id".to_string()))?
                .parse().map_err(|_| Error::ParseError("Id".to_string()))?,
        })
    }

    /// RefreshShareIndex
    ///
    /// Updates the music library (share) index
    ///
    /// Parameters:
    /// * `album_artist_display_option` : `WMP`, `ITUNES` or `NONE`
    pub async fn refresh_share_index(
            &self,
            album_artist_display_option: String
        ) -> Result<(), Error> {
        let payload = [
            serde_xml_rs::to_string(&album_artist_display_option).unwrap(),
        ].concat();
        self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        Ok(())
    }

    /// RequestResort
    ///
    /// Parameters:
    /// * `sort_order`
    pub async fn request_resort(
            &self,
            sort_order: String
        ) -> Result<(), Error> {
        let payload = [
            serde_xml_rs::to_string(&sort_order).unwrap(),
        ].concat();
        self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        Ok(())
    }

    /// SetBrowseable
    ///
    /// Parameters:
    /// * `browseable`
    pub async fn set_browseable(
            &self,
            browseable: bool
        ) -> Result<(), Error> {
        let payload = [
            serde_xml_rs::to_string(&browseable).unwrap(),
        ].concat();
        self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        Ok(())
    }

    /// UpdateObject
    ///
    /// Parameters:
    /// * `object_id`
    /// * `current_tag_value`
    /// * `new_tag_value`
    pub async fn update_object(
            &self,
            object_id: String,
            current_tag_value: String,
            new_tag_value: String
        ) -> Result<(), Error> {
        let payload = [
            serde_xml_rs::to_string(&object_id).unwrap(),
            serde_xml_rs::to_string(&current_tag_value).unwrap(),
            serde_xml_rs::to_string(&new_tag_value).unwrap(),
        ].concat();
        self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        Ok(())
    }
}

#[derive(Debug)]
pub struct BrowseResult {
    /// Encoded DIDL-Lite XML. See remark (2)
    pub result: String,
    pub number_returned: u32,
    pub total_matches: u32,
    pub update_id: u32,
}

#[derive(Debug)]
pub struct CreateObjectResult {
    pub object_id: String,
    pub result: String,
}

#[derive(Debug)]
pub struct FindPrefixResult {
    pub starting_index: u32,
    pub update_id: u32,
}

#[derive(Debug)]
pub struct GetAlbumArtistDisplayOptionResult {
    pub album_artist_display_option: String,
}

#[derive(Debug)]
pub struct GetAllPrefixLocationsResult {
    pub total_prefixes: u32,
    pub prefix_and_index_csv: String,
    pub update_id: u32,
}

#[derive(Debug)]
pub struct GetBrowseableResult {
    pub is_browseable: bool,
}

#[derive(Debug)]
pub struct GetLastIndexChangeResult {
    pub last_index_change: String,
}

#[derive(Debug)]
pub struct GetSearchCapabilitiesResult {
    pub search_caps: String,
}

#[derive(Debug)]
pub struct GetShareIndexInProgressResult {
    pub is_indexing: bool,
}

#[derive(Debug)]
pub struct GetSortCapabilitiesResult {
    pub sort_caps: String,
}

#[derive(Debug)]
pub struct GetSystemUpdateIDResult {
    pub id: u32,
}

