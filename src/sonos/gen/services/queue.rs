// Generated by sonos-docs, do not edit.

use rupnp::{Device, Service};
use rupnp::http::Uri;
use rupnp::ssdp::URN;use crate::sonos::gen::errors::Error;

/// Sonos QueueService
///
/// Modify and browse queues
#[derive(Debug)]
pub struct QueueService {
    service: Service,
    url: Uri,
}

impl QueueService {
    /// Create a new QueueService instance from an existing UPnP device.
    pub async fn from_device(device: Device) -> Option<Self> {
        let urn = "urn:schemas-sonos-com:service:Queue:1".parse::<URN>().unwrap();
        if let Some(s) = device.find_service(&urn) {
            Some(Self{ service: s.clone(), url: device.url().clone() })
        } else {
            None
        }
    }

    /// AddMultipleURIs
    ///
    /// Parameters:
    /// * `queue_id`
    /// * `update_id`
    /// * `container_uri`
    /// * `container_meta_data`
    /// * `desired_first_track_number_enqueued`
    /// * `enqueue_as_next`
    /// * `number_of_uris`
    /// * `enqueued_uris_and_meta_data`
    ///
    /// Outputs:
    /// * `first_track_number_enqueued`
    /// * `num_tracks_added`
    /// * `new_queue_length`
    /// * `new_update_id`
    pub async fn add_multiple_uris(
            &self,
            queue_id: u32,
            update_id: u32,
            container_uri: String,
            container_meta_data: String,
            desired_first_track_number_enqueued: u32,
            enqueue_as_next: bool,
            number_of_uris: u32,
            enqueued_uris_and_meta_data: String
        ) -> Result<AddMultipleURIsResult, Error> {
        // TODO: use xml helper
        let mut payload = String::new();
        payload.push_str(format!("<QueueID>{}</QueueID>", queue_id).as_str());
        payload.push_str(format!("<UpdateID>{}</UpdateID>", update_id).as_str());
        payload.push_str(format!("<ContainerURI>{}</ContainerURI>", container_uri).as_str());
        payload.push_str(format!("<ContainerMetaData>{}</ContainerMetaData>", container_meta_data).as_str());
        payload.push_str(format!("<DesiredFirstTrackNumberEnqueued>{}</DesiredFirstTrackNumberEnqueued>", desired_first_track_number_enqueued).as_str());
        payload.push_str(format!("<EnqueueAsNext>{}</EnqueueAsNext>", enqueue_as_next).as_str());
        payload.push_str(format!("<NumberOfURIs>{}</NumberOfURIs>", number_of_uris).as_str());
        payload.push_str(format!("<EnqueuedURIsAndMetaData>{}</EnqueuedURIsAndMetaData>", enqueued_uris_and_meta_data).as_str());
        let response = self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        // TODO: map parse errors
        Ok(AddMultipleURIsResult {
            first_track_number_enqueued: response.get("FirstTrackNumberEnqueued").ok_or_else(|| Error::MissingField("FirstTrackNumberEnqueued".to_string()))?
                .parse().map_err(|_| Error::ParseError("FirstTrackNumberEnqueued".to_string()))?,
            num_tracks_added: response.get("NumTracksAdded").ok_or_else(|| Error::MissingField("NumTracksAdded".to_string()))?
                .parse().map_err(|_| Error::ParseError("NumTracksAdded".to_string()))?,
            new_queue_length: response.get("NewQueueLength").ok_or_else(|| Error::MissingField("NewQueueLength".to_string()))?
                .parse().map_err(|_| Error::ParseError("NewQueueLength".to_string()))?,
            new_update_id: response.get("NewUpdateID").ok_or_else(|| Error::MissingField("NewUpdateID".to_string()))?
                .parse().map_err(|_| Error::ParseError("NewUpdateID".to_string()))?,
        })
    }

    /// AddURI
    ///
    /// Parameters:
    /// * `queue_id`
    /// * `update_id`
    /// * `enqueued_uri`
    /// * `enqueued_urimeta_data`
    /// * `desired_first_track_number_enqueued`
    /// * `enqueue_as_next`
    ///
    /// Outputs:
    /// * `first_track_number_enqueued`
    /// * `num_tracks_added`
    /// * `new_queue_length`
    /// * `new_update_id`
    pub async fn add_uri(
            &self,
            queue_id: u32,
            update_id: u32,
            enqueued_uri: String,
            enqueued_urimeta_data: String,
            desired_first_track_number_enqueued: u32,
            enqueue_as_next: bool
        ) -> Result<AddURIResult, Error> {
        // TODO: use xml helper
        let mut payload = String::new();
        payload.push_str(format!("<QueueID>{}</QueueID>", queue_id).as_str());
        payload.push_str(format!("<UpdateID>{}</UpdateID>", update_id).as_str());
        payload.push_str(format!("<EnqueuedURI>{}</EnqueuedURI>", enqueued_uri).as_str());
        payload.push_str(format!("<EnqueuedURIMetaData>{}</EnqueuedURIMetaData>", enqueued_urimeta_data).as_str());
        payload.push_str(format!("<DesiredFirstTrackNumberEnqueued>{}</DesiredFirstTrackNumberEnqueued>", desired_first_track_number_enqueued).as_str());
        payload.push_str(format!("<EnqueueAsNext>{}</EnqueueAsNext>", enqueue_as_next).as_str());
        let response = self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        // TODO: map parse errors
        Ok(AddURIResult {
            first_track_number_enqueued: response.get("FirstTrackNumberEnqueued").ok_or_else(|| Error::MissingField("FirstTrackNumberEnqueued".to_string()))?
                .parse().map_err(|_| Error::ParseError("FirstTrackNumberEnqueued".to_string()))?,
            num_tracks_added: response.get("NumTracksAdded").ok_or_else(|| Error::MissingField("NumTracksAdded".to_string()))?
                .parse().map_err(|_| Error::ParseError("NumTracksAdded".to_string()))?,
            new_queue_length: response.get("NewQueueLength").ok_or_else(|| Error::MissingField("NewQueueLength".to_string()))?
                .parse().map_err(|_| Error::ParseError("NewQueueLength".to_string()))?,
            new_update_id: response.get("NewUpdateID").ok_or_else(|| Error::MissingField("NewUpdateID".to_string()))?
                .parse().map_err(|_| Error::ParseError("NewUpdateID".to_string()))?,
        })
    }

    /// AttachQueue
    ///
    /// Parameters:
    /// * `queue_owner_id`
    ///
    /// Outputs:
    /// * `queue_id`
    /// * `queue_owner_context`
    pub async fn attach_queue(
            &self,
            queue_owner_id: String
        ) -> Result<AttachQueueResult, Error> {
        // TODO: use xml helper
        let mut payload = String::new();
        payload.push_str(format!("<QueueOwnerID>{}</QueueOwnerID>", queue_owner_id).as_str());
        let response = self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        // TODO: map parse errors
        Ok(AttachQueueResult {
            queue_id: response.get("QueueID").ok_or_else(|| Error::MissingField("QueueID".to_string()))?
                .parse().map_err(|_| Error::ParseError("QueueID".to_string()))?,
            queue_owner_context: response.get("QueueOwnerContext").ok_or_else(|| Error::MissingField("QueueOwnerContext".to_string()))?
                .parse().map_err(|_| Error::ParseError("QueueOwnerContext".to_string()))?,
        })
    }

    /// Backup
    pub async fn backup(
            &self,
        ) -> Result<(), Error> {
        let payload = String::new();
        self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        Ok(())
    }

    /// Browse
    ///
    /// Parameters:
    /// * `queue_id`
    /// * `starting_index`
    /// * `requested_count`
    ///
    /// Outputs:
    /// * `result`
    /// * `number_returned`
    /// * `total_matches`
    /// * `update_id`
    pub async fn browse(
            &self,
            queue_id: u32,
            starting_index: u32,
            requested_count: u32
        ) -> Result<BrowseResult, Error> {
        // TODO: use xml helper
        let mut payload = String::new();
        payload.push_str(format!("<QueueID>{}</QueueID>", queue_id).as_str());
        payload.push_str(format!("<StartingIndex>{}</StartingIndex>", starting_index).as_str());
        payload.push_str(format!("<RequestedCount>{}</RequestedCount>", requested_count).as_str());
        let response = self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        // TODO: map parse errors
        Ok(BrowseResult {
            result: response.get("Result").ok_or_else(|| Error::MissingField("Result".to_string()))?
                .parse().map_err(|_| Error::ParseError("Result".to_string()))?,
            number_returned: response.get("NumberReturned").ok_or_else(|| Error::MissingField("NumberReturned".to_string()))?
                .parse().map_err(|_| Error::ParseError("NumberReturned".to_string()))?,
            total_matches: response.get("TotalMatches").ok_or_else(|| Error::MissingField("TotalMatches".to_string()))?
                .parse().map_err(|_| Error::ParseError("TotalMatches".to_string()))?,
            update_id: response.get("UpdateID").ok_or_else(|| Error::MissingField("UpdateID".to_string()))?
                .parse().map_err(|_| Error::ParseError("UpdateID".to_string()))?,
        })
    }

    /// CreateQueue
    ///
    /// Parameters:
    /// * `queue_owner_id`
    /// * `queue_owner_context`
    /// * `queue_policy`
    ///
    /// Outputs:
    /// * `queue_id`
    pub async fn create_queue(
            &self,
            queue_owner_id: String,
            queue_owner_context: String,
            queue_policy: String
        ) -> Result<CreateQueueResult, Error> {
        // TODO: use xml helper
        let mut payload = String::new();
        payload.push_str(format!("<QueueOwnerID>{}</QueueOwnerID>", queue_owner_id).as_str());
        payload.push_str(format!("<QueueOwnerContext>{}</QueueOwnerContext>", queue_owner_context).as_str());
        payload.push_str(format!("<QueuePolicy>{}</QueuePolicy>", queue_policy).as_str());
        let response = self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        // TODO: map parse errors
        Ok(CreateQueueResult {
            queue_id: response.get("QueueID").ok_or_else(|| Error::MissingField("QueueID".to_string()))?
                .parse().map_err(|_| Error::ParseError("QueueID".to_string()))?,
        })
    }

    /// RemoveAllTracks
    ///
    /// Parameters:
    /// * `queue_id`
    /// * `update_id`
    ///
    /// Outputs:
    /// * `new_update_id`
    pub async fn remove_all_tracks(
            &self,
            queue_id: u32,
            update_id: u32
        ) -> Result<RemoveAllTracksResult, Error> {
        // TODO: use xml helper
        let mut payload = String::new();
        payload.push_str(format!("<QueueID>{}</QueueID>", queue_id).as_str());
        payload.push_str(format!("<UpdateID>{}</UpdateID>", update_id).as_str());
        let response = self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        // TODO: map parse errors
        Ok(RemoveAllTracksResult {
            new_update_id: response.get("NewUpdateID").ok_or_else(|| Error::MissingField("NewUpdateID".to_string()))?
                .parse().map_err(|_| Error::ParseError("NewUpdateID".to_string()))?,
        })
    }

    /// RemoveTrackRange
    ///
    /// Parameters:
    /// * `queue_id`
    /// * `update_id`
    /// * `starting_index`
    /// * `number_of_tracks`
    ///
    /// Outputs:
    /// * `new_update_id`
    pub async fn remove_track_range(
            &self,
            queue_id: u32,
            update_id: u32,
            starting_index: u32,
            number_of_tracks: u32
        ) -> Result<RemoveTrackRangeResult, Error> {
        // TODO: use xml helper
        let mut payload = String::new();
        payload.push_str(format!("<QueueID>{}</QueueID>", queue_id).as_str());
        payload.push_str(format!("<UpdateID>{}</UpdateID>", update_id).as_str());
        payload.push_str(format!("<StartingIndex>{}</StartingIndex>", starting_index).as_str());
        payload.push_str(format!("<NumberOfTracks>{}</NumberOfTracks>", number_of_tracks).as_str());
        let response = self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        // TODO: map parse errors
        Ok(RemoveTrackRangeResult {
            new_update_id: response.get("NewUpdateID").ok_or_else(|| Error::MissingField("NewUpdateID".to_string()))?
                .parse().map_err(|_| Error::ParseError("NewUpdateID".to_string()))?,
        })
    }

    /// ReorderTracks
    ///
    /// Parameters:
    /// * `queue_id`
    /// * `starting_index`
    /// * `number_of_tracks`
    /// * `insert_before`
    /// * `update_id`
    ///
    /// Outputs:
    /// * `new_update_id`
    pub async fn reorder_tracks(
            &self,
            queue_id: u32,
            starting_index: u32,
            number_of_tracks: u32,
            insert_before: u32,
            update_id: u32
        ) -> Result<ReorderTracksResult, Error> {
        // TODO: use xml helper
        let mut payload = String::new();
        payload.push_str(format!("<QueueID>{}</QueueID>", queue_id).as_str());
        payload.push_str(format!("<StartingIndex>{}</StartingIndex>", starting_index).as_str());
        payload.push_str(format!("<NumberOfTracks>{}</NumberOfTracks>", number_of_tracks).as_str());
        payload.push_str(format!("<InsertBefore>{}</InsertBefore>", insert_before).as_str());
        payload.push_str(format!("<UpdateID>{}</UpdateID>", update_id).as_str());
        let response = self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        // TODO: map parse errors
        Ok(ReorderTracksResult {
            new_update_id: response.get("NewUpdateID").ok_or_else(|| Error::MissingField("NewUpdateID".to_string()))?
                .parse().map_err(|_| Error::ParseError("NewUpdateID".to_string()))?,
        })
    }

    /// ReplaceAllTracks
    ///
    /// Parameters:
    /// * `queue_id`
    /// * `update_id`
    /// * `container_uri`
    /// * `container_meta_data`
    /// * `current_track_index`
    /// * `new_current_track_indices`
    /// * `number_of_uris`
    /// * `enqueued_uris_and_meta_data`
    ///
    /// Outputs:
    /// * `new_queue_length`
    /// * `new_update_id`
    pub async fn replace_all_tracks(
            &self,
            queue_id: u32,
            update_id: u32,
            container_uri: String,
            container_meta_data: String,
            current_track_index: u32,
            new_current_track_indices: String,
            number_of_uris: u32,
            enqueued_uris_and_meta_data: String
        ) -> Result<ReplaceAllTracksResult, Error> {
        // TODO: use xml helper
        let mut payload = String::new();
        payload.push_str(format!("<QueueID>{}</QueueID>", queue_id).as_str());
        payload.push_str(format!("<UpdateID>{}</UpdateID>", update_id).as_str());
        payload.push_str(format!("<ContainerURI>{}</ContainerURI>", container_uri).as_str());
        payload.push_str(format!("<ContainerMetaData>{}</ContainerMetaData>", container_meta_data).as_str());
        payload.push_str(format!("<CurrentTrackIndex>{}</CurrentTrackIndex>", current_track_index).as_str());
        payload.push_str(format!("<NewCurrentTrackIndices>{}</NewCurrentTrackIndices>", new_current_track_indices).as_str());
        payload.push_str(format!("<NumberOfURIs>{}</NumberOfURIs>", number_of_uris).as_str());
        payload.push_str(format!("<EnqueuedURIsAndMetaData>{}</EnqueuedURIsAndMetaData>", enqueued_uris_and_meta_data).as_str());
        let response = self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        // TODO: map parse errors
        Ok(ReplaceAllTracksResult {
            new_queue_length: response.get("NewQueueLength").ok_or_else(|| Error::MissingField("NewQueueLength".to_string()))?
                .parse().map_err(|_| Error::ParseError("NewQueueLength".to_string()))?,
            new_update_id: response.get("NewUpdateID").ok_or_else(|| Error::MissingField("NewUpdateID".to_string()))?
                .parse().map_err(|_| Error::ParseError("NewUpdateID".to_string()))?,
        })
    }

    /// SaveAsSonosPlaylist
    ///
    /// Parameters:
    /// * `queue_id`
    /// * `title`
    /// * `object_id`
    ///
    /// Outputs:
    /// * `assigned_object_id`
    pub async fn save_as_sonos_playlist(
            &self,
            queue_id: u32,
            title: String,
            object_id: String
        ) -> Result<SaveAsSonosPlaylistResult, Error> {
        // TODO: use xml helper
        let mut payload = String::new();
        payload.push_str(format!("<QueueID>{}</QueueID>", queue_id).as_str());
        payload.push_str(format!("<Title>{}</Title>", title).as_str());
        payload.push_str(format!("<ObjectID>{}</ObjectID>", object_id).as_str());
        let response = self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        // TODO: map parse errors
        Ok(SaveAsSonosPlaylistResult {
            assigned_object_id: response.get("AssignedObjectID").ok_or_else(|| Error::MissingField("AssignedObjectID".to_string()))?
                .parse().map_err(|_| Error::ParseError("AssignedObjectID".to_string()))?,
        })
    }
}

#[derive(Debug)]
pub struct AddMultipleURIsResult {
    pub first_track_number_enqueued: u32,
    pub num_tracks_added: u32,
    pub new_queue_length: u32,
    pub new_update_id: u32,
}

#[derive(Debug)]
pub struct AddURIResult {
    pub first_track_number_enqueued: u32,
    pub num_tracks_added: u32,
    pub new_queue_length: u32,
    pub new_update_id: u32,
}

#[derive(Debug)]
pub struct AttachQueueResult {
    pub queue_id: u32,
    pub queue_owner_context: String,
}

#[derive(Debug)]
pub struct BrowseResult {
    pub result: String,
    pub number_returned: u32,
    pub total_matches: u32,
    pub update_id: u32,
}

#[derive(Debug)]
pub struct CreateQueueResult {
    pub queue_id: u32,
}

#[derive(Debug)]
pub struct RemoveAllTracksResult {
    pub new_update_id: u32,
}

#[derive(Debug)]
pub struct RemoveTrackRangeResult {
    pub new_update_id: u32,
}

#[derive(Debug)]
pub struct ReorderTracksResult {
    pub new_update_id: u32,
}

#[derive(Debug)]
pub struct ReplaceAllTracksResult {
    pub new_queue_length: u32,
    pub new_update_id: u32,
}

#[derive(Debug)]
pub struct SaveAsSonosPlaylistResult {
    pub assigned_object_id: String,
}
