// Generated by sonos-docs, do not edit.

use rupnp::{Device, Service};
use rupnp::http::Uri;
use rupnp::ssdp::URN;use crate::sonos::gen::errors::Error;

/// Sonos RenderingControlService
///
/// Volume related controls
#[derive(Debug)]
pub struct RenderingControlService {
    service: Service,
    url: Uri,
}

impl RenderingControlService {
    /// Create a new RenderingControlService instance from an existing UPnP device.
    pub async fn from_device(device: Device) -> Option<Self> {
        let urn = "urn:schemas-upnp-org:service:RenderingControl:1".parse::<URN>().unwrap();
        if let Some(s) = device.find_service(&urn) {
            Some(Self{ service: s.clone(), url: device.url().clone() })
        } else {
            None
        }
    }

    /// GetBass
    ///
    /// Get bass level between -10 and 10
    ///
    /// Parameters:
    /// * `instance_id` : InstanceID should always be `0`
    ///
    /// Outputs:
    /// * `current_bass`
    pub async fn get_bass(
            &self,
            instance_id: u32
        ) -> Result<GetBassResult, Error> {
        // TODO: use xml helper
        let mut payload = String::new();
        payload.push_str(format!("<InstanceID>{}</InstanceID>", instance_id).as_str());
        let response = self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        // TODO: map parse errors
        Ok(GetBassResult {
            current_bass: response.get("CurrentBass").ok_or_else(|| Error::MissingField("CurrentBass".to_string()))?
                .parse().map_err(|_| Error::ParseError("CurrentBass".to_string()))?,
        })
    }

    /// GetEQ
    ///
    /// Get equalizer value
    ///
    /// Note: Not all EQ types are available on every speaker
    ///
    /// Parameters:
    /// * `instance_id` : InstanceID should always be `0`
    /// * `eqtype` : Allowed values `DialogLevel` (bool) / `MusicSurroundLevel` (-15/+15) /  `NightMode` (bool) / `SubGain` (-10/+10) / `SurroundEnable` (bool) / `SurroundLevel` (-15/+15) / `SurroundMode` (0 = ambient, 1 = full) / `HeightChannelLevel` (-10/+10)
    ///
    /// Outputs:
    /// * `current_value` : Booleans return `1` / `0`, rest number as specified
    pub async fn get_eq(
            &self,
            instance_id: u32,
            eqtype: String
        ) -> Result<GetEQResult, Error> {
        // TODO: use xml helper
        let mut payload = String::new();
        payload.push_str(format!("<InstanceID>{}</InstanceID>", instance_id).as_str());
        payload.push_str(format!("<EQType>{}</EQType>", eqtype).as_str());
        let response = self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        // TODO: map parse errors
        Ok(GetEQResult {
            current_value: response.get("CurrentValue").ok_or_else(|| Error::MissingField("CurrentValue".to_string()))?
                .parse().map_err(|_| Error::ParseError("CurrentValue".to_string()))?,
        })
    }

    /// GetHeadphoneConnected
    ///
    /// Parameters:
    /// * `instance_id` : InstanceID should always be `0`
    ///
    /// Outputs:
    /// * `current_headphone_connected`
    pub async fn get_headphone_connected(
            &self,
            instance_id: u32
        ) -> Result<GetHeadphoneConnectedResult, Error> {
        // TODO: use xml helper
        let mut payload = String::new();
        payload.push_str(format!("<InstanceID>{}</InstanceID>", instance_id).as_str());
        let response = self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        // TODO: map parse errors
        Ok(GetHeadphoneConnectedResult {
            current_headphone_connected: response.get("CurrentHeadphoneConnected").ok_or_else(|| Error::MissingField("CurrentHeadphoneConnected".to_string()))?
                .parse().map_err(|_| Error::ParseError("CurrentHeadphoneConnected".to_string()))?,
        })
    }

    /// GetLoudness
    ///
    /// Whether or not Loudness is on
    ///
    /// Parameters:
    /// * `instance_id` : InstanceID should always be `0`
    /// * `channel`
    ///
    /// Outputs:
    /// * `current_loudness`
    pub async fn get_loudness(
            &self,
            instance_id: u32,
            channel: String
        ) -> Result<GetLoudnessResult, Error> {
        // TODO: use xml helper
        let mut payload = String::new();
        payload.push_str(format!("<InstanceID>{}</InstanceID>", instance_id).as_str());
        payload.push_str(format!("<Channel>{}</Channel>", channel).as_str());
        let response = self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        // TODO: map parse errors
        Ok(GetLoudnessResult {
            current_loudness: response.get("CurrentLoudness").ok_or_else(|| Error::MissingField("CurrentLoudness".to_string()))?
                .parse().map_err(|_| Error::ParseError("CurrentLoudness".to_string()))?,
        })
    }

    /// GetMute
    ///
    /// Parameters:
    /// * `instance_id` : InstanceID should always be `0`
    /// * `channel`
    ///
    /// Outputs:
    /// * `current_mute`
    pub async fn get_mute(
            &self,
            instance_id: u32,
            channel: String
        ) -> Result<GetMuteResult, Error> {
        // TODO: use xml helper
        let mut payload = String::new();
        payload.push_str(format!("<InstanceID>{}</InstanceID>", instance_id).as_str());
        payload.push_str(format!("<Channel>{}</Channel>", channel).as_str());
        let response = self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        // TODO: map parse errors
        Ok(GetMuteResult {
            current_mute: response.get("CurrentMute").ok_or_else(|| Error::MissingField("CurrentMute".to_string()))?
                .parse().map_err(|_| Error::ParseError("CurrentMute".to_string()))?,
        })
    }

    /// GetOutputFixed
    ///
    /// Parameters:
    /// * `instance_id` : InstanceID should always be `0`
    ///
    /// Outputs:
    /// * `current_fixed`
    pub async fn get_output_fixed(
            &self,
            instance_id: u32
        ) -> Result<GetOutputFixedResult, Error> {
        // TODO: use xml helper
        let mut payload = String::new();
        payload.push_str(format!("<InstanceID>{}</InstanceID>", instance_id).as_str());
        let response = self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        // TODO: map parse errors
        Ok(GetOutputFixedResult {
            current_fixed: response.get("CurrentFixed").ok_or_else(|| Error::MissingField("CurrentFixed".to_string()))?
                .parse().map_err(|_| Error::ParseError("CurrentFixed".to_string()))?,
        })
    }

    /// GetRoomCalibrationStatus
    ///
    /// Parameters:
    /// * `instance_id` : InstanceID should always be `0`
    ///
    /// Outputs:
    /// * `room_calibration_enabled`
    /// * `room_calibration_available`
    pub async fn get_room_calibration_status(
            &self,
            instance_id: u32
        ) -> Result<GetRoomCalibrationStatusResult, Error> {
        // TODO: use xml helper
        let mut payload = String::new();
        payload.push_str(format!("<InstanceID>{}</InstanceID>", instance_id).as_str());
        let response = self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        // TODO: map parse errors
        Ok(GetRoomCalibrationStatusResult {
            room_calibration_enabled: response.get("RoomCalibrationEnabled").ok_or_else(|| Error::MissingField("RoomCalibrationEnabled".to_string()))?
                .parse().map_err(|_| Error::ParseError("RoomCalibrationEnabled".to_string()))?,
            room_calibration_available: response.get("RoomCalibrationAvailable").ok_or_else(|| Error::MissingField("RoomCalibrationAvailable".to_string()))?
                .parse().map_err(|_| Error::ParseError("RoomCalibrationAvailable".to_string()))?,
        })
    }

    /// GetSupportsOutputFixed
    ///
    /// Parameters:
    /// * `instance_id` : InstanceID should always be `0`
    ///
    /// Outputs:
    /// * `current_supports_fixed`
    pub async fn get_supports_output_fixed(
            &self,
            instance_id: u32
        ) -> Result<GetSupportsOutputFixedResult, Error> {
        // TODO: use xml helper
        let mut payload = String::new();
        payload.push_str(format!("<InstanceID>{}</InstanceID>", instance_id).as_str());
        let response = self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        // TODO: map parse errors
        Ok(GetSupportsOutputFixedResult {
            current_supports_fixed: response.get("CurrentSupportsFixed").ok_or_else(|| Error::MissingField("CurrentSupportsFixed".to_string()))?
                .parse().map_err(|_| Error::ParseError("CurrentSupportsFixed".to_string()))?,
        })
    }

    /// GetTreble
    ///
    /// Get treble
    ///
    /// Parameters:
    /// * `instance_id` : InstanceID should always be `0`
    ///
    /// Outputs:
    /// * `current_treble` : Number between -10 and 10
    pub async fn get_treble(
            &self,
            instance_id: u32
        ) -> Result<GetTrebleResult, Error> {
        // TODO: use xml helper
        let mut payload = String::new();
        payload.push_str(format!("<InstanceID>{}</InstanceID>", instance_id).as_str());
        let response = self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        // TODO: map parse errors
        Ok(GetTrebleResult {
            current_treble: response.get("CurrentTreble").ok_or_else(|| Error::MissingField("CurrentTreble".to_string()))?
                .parse().map_err(|_| Error::ParseError("CurrentTreble".to_string()))?,
        })
    }

    /// GetVolume
    ///
    /// Get volume
    ///
    /// Parameters:
    /// * `instance_id` : InstanceID should always be `0`
    /// * `channel`
    ///
    /// Outputs:
    /// * `current_volume` : Number between 0 and 100
    pub async fn get_volume(
            &self,
            instance_id: u32,
            channel: String
        ) -> Result<GetVolumeResult, Error> {
        // TODO: use xml helper
        let mut payload = String::new();
        payload.push_str(format!("<InstanceID>{}</InstanceID>", instance_id).as_str());
        payload.push_str(format!("<Channel>{}</Channel>", channel).as_str());
        let response = self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        // TODO: map parse errors
        Ok(GetVolumeResult {
            current_volume: response.get("CurrentVolume").ok_or_else(|| Error::MissingField("CurrentVolume".to_string()))?
                .parse().map_err(|_| Error::ParseError("CurrentVolume".to_string()))?,
        })
    }

    /// GetVolumeDB
    ///
    /// Parameters:
    /// * `instance_id` : InstanceID should always be `0`
    /// * `channel`
    ///
    /// Outputs:
    /// * `current_volume`
    pub async fn get_volume_db(
            &self,
            instance_id: u32,
            channel: String
        ) -> Result<GetVolumeDBResult, Error> {
        // TODO: use xml helper
        let mut payload = String::new();
        payload.push_str(format!("<InstanceID>{}</InstanceID>", instance_id).as_str());
        payload.push_str(format!("<Channel>{}</Channel>", channel).as_str());
        let response = self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        // TODO: map parse errors
        Ok(GetVolumeDBResult {
            current_volume: response.get("CurrentVolume").ok_or_else(|| Error::MissingField("CurrentVolume".to_string()))?
                .parse().map_err(|_| Error::ParseError("CurrentVolume".to_string()))?,
        })
    }

    /// GetVolumeDBRange
    ///
    /// Parameters:
    /// * `instance_id` : InstanceID should always be `0`
    /// * `channel`
    ///
    /// Outputs:
    /// * `min_value`
    /// * `max_value`
    pub async fn get_volume_dbrange(
            &self,
            instance_id: u32,
            channel: String
        ) -> Result<GetVolumeDBRangeResult, Error> {
        // TODO: use xml helper
        let mut payload = String::new();
        payload.push_str(format!("<InstanceID>{}</InstanceID>", instance_id).as_str());
        payload.push_str(format!("<Channel>{}</Channel>", channel).as_str());
        let response = self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        // TODO: map parse errors
        Ok(GetVolumeDBRangeResult {
            min_value: response.get("MinValue").ok_or_else(|| Error::MissingField("MinValue".to_string()))?
                .parse().map_err(|_| Error::ParseError("MinValue".to_string()))?,
            max_value: response.get("MaxValue").ok_or_else(|| Error::MissingField("MaxValue".to_string()))?
                .parse().map_err(|_| Error::ParseError("MaxValue".to_string()))?,
        })
    }

    /// RampToVolume
    ///
    /// Parameters:
    /// * `instance_id` : InstanceID should always be `0`
    /// * `channel`
    /// * `ramp_type`
    /// * `desired_volume`
    /// * `reset_volume_after`
    /// * `program_uri`
    ///
    /// Outputs:
    /// * `ramp_time`
    pub async fn ramp_to_volume(
            &self,
            instance_id: u32,
            channel: String,
            ramp_type: String,
            desired_volume: u16,
            reset_volume_after: bool,
            program_uri: String
        ) -> Result<RampToVolumeResult, Error> {
        // TODO: use xml helper
        let mut payload = String::new();
        payload.push_str(format!("<InstanceID>{}</InstanceID>", instance_id).as_str());
        payload.push_str(format!("<Channel>{}</Channel>", channel).as_str());
        payload.push_str(format!("<RampType>{}</RampType>", ramp_type).as_str());
        payload.push_str(format!("<DesiredVolume>{}</DesiredVolume>", desired_volume).as_str());
        payload.push_str(format!("<ResetVolumeAfter>{}</ResetVolumeAfter>", reset_volume_after).as_str());
        payload.push_str(format!("<ProgramURI>{}</ProgramURI>", program_uri).as_str());
        let response = self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        // TODO: map parse errors
        Ok(RampToVolumeResult {
            ramp_time: response.get("RampTime").ok_or_else(|| Error::MissingField("RampTime".to_string()))?
                .parse().map_err(|_| Error::ParseError("RampTime".to_string()))?,
        })
    }

    /// ResetBasicEQ
    ///
    /// Parameters:
    /// * `instance_id` : InstanceID should always be `0`
    ///
    /// Outputs:
    /// * `bass`
    /// * `treble`
    /// * `loudness`
    /// * `left_volume`
    /// * `right_volume`
    pub async fn reset_basic_eq(
            &self,
            instance_id: u32
        ) -> Result<ResetBasicEQResult, Error> {
        // TODO: use xml helper
        let mut payload = String::new();
        payload.push_str(format!("<InstanceID>{}</InstanceID>", instance_id).as_str());
        let response = self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        // TODO: map parse errors
        Ok(ResetBasicEQResult {
            bass: response.get("Bass").ok_or_else(|| Error::MissingField("Bass".to_string()))?
                .parse().map_err(|_| Error::ParseError("Bass".to_string()))?,
            treble: response.get("Treble").ok_or_else(|| Error::MissingField("Treble".to_string()))?
                .parse().map_err(|_| Error::ParseError("Treble".to_string()))?,
            loudness: response.get("Loudness").ok_or_else(|| Error::MissingField("Loudness".to_string()))?
                .parse().map_err(|_| Error::ParseError("Loudness".to_string()))?,
            left_volume: response.get("LeftVolume").ok_or_else(|| Error::MissingField("LeftVolume".to_string()))?
                .parse().map_err(|_| Error::ParseError("LeftVolume".to_string()))?,
            right_volume: response.get("RightVolume").ok_or_else(|| Error::MissingField("RightVolume".to_string()))?
                .parse().map_err(|_| Error::ParseError("RightVolume".to_string()))?,
        })
    }

    /// ResetExtEQ
    ///
    /// Parameters:
    /// * `instance_id` : InstanceID should always be `0`
    /// * `eqtype`
    pub async fn reset_ext_eq(
            &self,
            instance_id: u32,
            eqtype: String
        ) -> Result<(), Error> {
        // TODO: use xml helper
        let mut payload = String::new();
        payload.push_str(format!("<InstanceID>{}</InstanceID>", instance_id).as_str());
        payload.push_str(format!("<EQType>{}</EQType>", eqtype).as_str());
        self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        Ok(())
    }

    /// RestoreVolumePriorToRamp
    ///
    /// Parameters:
    /// * `instance_id` : InstanceID should always be `0`
    /// * `channel`
    pub async fn restore_volume_prior_to_ramp(
            &self,
            instance_id: u32,
            channel: String
        ) -> Result<(), Error> {
        // TODO: use xml helper
        let mut payload = String::new();
        payload.push_str(format!("<InstanceID>{}</InstanceID>", instance_id).as_str());
        payload.push_str(format!("<Channel>{}</Channel>", channel).as_str());
        self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        Ok(())
    }

    /// SetBass
    ///
    /// Set bass level, between -10 and 10
    ///
    /// Parameters:
    /// * `instance_id` : InstanceID should always be `0`
    /// * `desired_bass`
    pub async fn set_bass(
            &self,
            instance_id: u32,
            desired_bass: i16
        ) -> Result<(), Error> {
        // TODO: use xml helper
        let mut payload = String::new();
        payload.push_str(format!("<InstanceID>{}</InstanceID>", instance_id).as_str());
        payload.push_str(format!("<DesiredBass>{}</DesiredBass>", desired_bass).as_str());
        self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        Ok(())
    }

    /// SetChannelMap
    ///
    /// Parameters:
    /// * `instance_id` : InstanceID should always be `0`
    /// * `channel_map`
    pub async fn set_channel_map(
            &self,
            instance_id: u32,
            channel_map: String
        ) -> Result<(), Error> {
        // TODO: use xml helper
        let mut payload = String::new();
        payload.push_str(format!("<InstanceID>{}</InstanceID>", instance_id).as_str());
        payload.push_str(format!("<ChannelMap>{}</ChannelMap>", channel_map).as_str());
        self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        Ok(())
    }

    /// SetEQ
    ///
    /// Set equalizer value for different types
    ///
    /// Note: Not supported by all speakers, TV related
    ///
    /// Parameters:
    /// * `instance_id` : InstanceID should always be `0`
    /// * `eqtype` : Allowed values `DialogLevel` (bool) / `MusicSurroundLevel` (-15/+15) /  `NightMode` (bool) / `SubGain` (-10/+10) / `SurroundEnable` (bool) / `SurroundLevel` (-15/+15) / `SurroundMode` (0 = ambient, 1 = full) / `HeightChannelLevel` (-10/+10)
    /// * `desired_value` : Booleans required `1` for true or `0` for false, rest number as specified
    pub async fn set_eq(
            &self,
            instance_id: u32,
            eqtype: String,
            desired_value: i16
        ) -> Result<(), Error> {
        // TODO: use xml helper
        let mut payload = String::new();
        payload.push_str(format!("<InstanceID>{}</InstanceID>", instance_id).as_str());
        payload.push_str(format!("<EQType>{}</EQType>", eqtype).as_str());
        payload.push_str(format!("<DesiredValue>{}</DesiredValue>", desired_value).as_str());
        self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        Ok(())
    }

    /// SetLoudness
    ///
    /// Set loudness on / off
    ///
    /// Parameters:
    /// * `instance_id` : InstanceID should always be `0`
    /// * `channel`
    /// * `desired_loudness`
    pub async fn set_loudness(
            &self,
            instance_id: u32,
            channel: String,
            desired_loudness: bool
        ) -> Result<(), Error> {
        // TODO: use xml helper
        let mut payload = String::new();
        payload.push_str(format!("<InstanceID>{}</InstanceID>", instance_id).as_str());
        payload.push_str(format!("<Channel>{}</Channel>", channel).as_str());
        payload.push_str(format!("<DesiredLoudness>{}</DesiredLoudness>", desired_loudness).as_str());
        self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        Ok(())
    }

    /// SetMute
    ///
    /// Parameters:
    /// * `instance_id` : InstanceID should always be `0`
    /// * `channel`
    /// * `desired_mute`
    pub async fn set_mute(
            &self,
            instance_id: u32,
            channel: String,
            desired_mute: bool
        ) -> Result<(), Error> {
        // TODO: use xml helper
        let mut payload = String::new();
        payload.push_str(format!("<InstanceID>{}</InstanceID>", instance_id).as_str());
        payload.push_str(format!("<Channel>{}</Channel>", channel).as_str());
        payload.push_str(format!("<DesiredMute>{}</DesiredMute>", desired_mute).as_str());
        self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        Ok(())
    }

    /// SetOutputFixed
    ///
    /// Parameters:
    /// * `instance_id` : InstanceID should always be `0`
    /// * `desired_fixed`
    pub async fn set_output_fixed(
            &self,
            instance_id: u32,
            desired_fixed: bool
        ) -> Result<(), Error> {
        // TODO: use xml helper
        let mut payload = String::new();
        payload.push_str(format!("<InstanceID>{}</InstanceID>", instance_id).as_str());
        payload.push_str(format!("<DesiredFixed>{}</DesiredFixed>", desired_fixed).as_str());
        self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        Ok(())
    }

    /// SetRelativeVolume
    ///
    /// Parameters:
    /// * `instance_id` : InstanceID should always be `0`
    /// * `channel`
    /// * `adjustment`
    ///
    /// Outputs:
    /// * `new_volume`
    pub async fn set_relative_volume(
            &self,
            instance_id: u32,
            channel: String,
            adjustment: i32
        ) -> Result<SetRelativeVolumeResult, Error> {
        // TODO: use xml helper
        let mut payload = String::new();
        payload.push_str(format!("<InstanceID>{}</InstanceID>", instance_id).as_str());
        payload.push_str(format!("<Channel>{}</Channel>", channel).as_str());
        payload.push_str(format!("<Adjustment>{}</Adjustment>", adjustment).as_str());
        let response = self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        // TODO: map parse errors
        Ok(SetRelativeVolumeResult {
            new_volume: response.get("NewVolume").ok_or_else(|| Error::MissingField("NewVolume".to_string()))?
                .parse().map_err(|_| Error::ParseError("NewVolume".to_string()))?,
        })
    }

    /// SetRoomCalibrationStatus
    ///
    /// Parameters:
    /// * `instance_id` : InstanceID should always be `0`
    /// * `room_calibration_enabled`
    pub async fn set_room_calibration_status(
            &self,
            instance_id: u32,
            room_calibration_enabled: bool
        ) -> Result<(), Error> {
        // TODO: use xml helper
        let mut payload = String::new();
        payload.push_str(format!("<InstanceID>{}</InstanceID>", instance_id).as_str());
        payload.push_str(format!("<RoomCalibrationEnabled>{}</RoomCalibrationEnabled>", room_calibration_enabled).as_str());
        self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        Ok(())
    }

    /// SetRoomCalibrationX
    ///
    /// Parameters:
    /// * `instance_id` : InstanceID should always be `0`
    /// * `calibration_id`
    /// * `coefficients`
    /// * `calibration_mode`
    pub async fn set_room_calibration_x(
            &self,
            instance_id: u32,
            calibration_id: String,
            coefficients: String,
            calibration_mode: String
        ) -> Result<(), Error> {
        // TODO: use xml helper
        let mut payload = String::new();
        payload.push_str(format!("<InstanceID>{}</InstanceID>", instance_id).as_str());
        payload.push_str(format!("<CalibrationID>{}</CalibrationID>", calibration_id).as_str());
        payload.push_str(format!("<Coefficients>{}</Coefficients>", coefficients).as_str());
        payload.push_str(format!("<CalibrationMode>{}</CalibrationMode>", calibration_mode).as_str());
        self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        Ok(())
    }

    /// SetTreble
    ///
    /// Set treble level
    ///
    /// Parameters:
    /// * `instance_id` : InstanceID should always be `0`
    /// * `desired_treble` : between -10 and 10
    pub async fn set_treble(
            &self,
            instance_id: u32,
            desired_treble: i16
        ) -> Result<(), Error> {
        // TODO: use xml helper
        let mut payload = String::new();
        payload.push_str(format!("<InstanceID>{}</InstanceID>", instance_id).as_str());
        payload.push_str(format!("<DesiredTreble>{}</DesiredTreble>", desired_treble).as_str());
        self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        Ok(())
    }

    /// SetVolume
    ///
    /// Parameters:
    /// * `instance_id` : InstanceID should always be `0`
    /// * `channel`
    /// * `desired_volume`
    pub async fn set_volume(
            &self,
            instance_id: u32,
            channel: String,
            desired_volume: u16
        ) -> Result<(), Error> {
        // TODO: use xml helper
        let mut payload = String::new();
        payload.push_str(format!("<InstanceID>{}</InstanceID>", instance_id).as_str());
        payload.push_str(format!("<Channel>{}</Channel>", channel).as_str());
        payload.push_str(format!("<DesiredVolume>{}</DesiredVolume>", desired_volume).as_str());
        self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        Ok(())
    }

    /// SetVolumeDB
    ///
    /// Parameters:
    /// * `instance_id` : InstanceID should always be `0`
    /// * `channel`
    /// * `desired_volume`
    pub async fn set_volume_db(
            &self,
            instance_id: u32,
            channel: String,
            desired_volume: i16
        ) -> Result<(), Error> {
        // TODO: use xml helper
        let mut payload = String::new();
        payload.push_str(format!("<InstanceID>{}</InstanceID>", instance_id).as_str());
        payload.push_str(format!("<Channel>{}</Channel>", channel).as_str());
        payload.push_str(format!("<DesiredVolume>{}</DesiredVolume>", desired_volume).as_str());
        self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        Ok(())
    }
}

#[derive(Debug)]
pub struct GetBassResult {
    pub current_bass: i16,
}

#[derive(Debug)]
pub struct GetEQResult {
    /// Booleans return `1` / `0`, rest number as specified
    pub current_value: i16,
}

#[derive(Debug)]
pub struct GetHeadphoneConnectedResult {
    pub current_headphone_connected: bool,
}

#[derive(Debug)]
pub struct GetLoudnessResult {
    pub current_loudness: bool,
}

#[derive(Debug)]
pub struct GetMuteResult {
    pub current_mute: bool,
}

#[derive(Debug)]
pub struct GetOutputFixedResult {
    pub current_fixed: bool,
}

#[derive(Debug)]
pub struct GetRoomCalibrationStatusResult {
    pub room_calibration_enabled: bool,
    pub room_calibration_available: bool,
}

#[derive(Debug)]
pub struct GetSupportsOutputFixedResult {
    pub current_supports_fixed: bool,
}

#[derive(Debug)]
pub struct GetTrebleResult {
    /// Number between -10 and 10
    pub current_treble: i16,
}

#[derive(Debug)]
pub struct GetVolumeResult {
    /// Number between 0 and 100
    pub current_volume: u16,
}

#[derive(Debug)]
pub struct GetVolumeDBResult {
    pub current_volume: i16,
}

#[derive(Debug)]
pub struct GetVolumeDBRangeResult {
    pub min_value: i16,
    pub max_value: i16,
}

#[derive(Debug)]
pub struct RampToVolumeResult {
    pub ramp_time: u32,
}

#[derive(Debug)]
pub struct ResetBasicEQResult {
    pub bass: i16,
    pub treble: i16,
    pub loudness: bool,
    pub left_volume: u16,
    pub right_volume: u16,
}

#[derive(Debug)]
pub struct SetRelativeVolumeResult {
    pub new_volume: u16,
}

