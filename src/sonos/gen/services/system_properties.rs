// Generated by sonos-docs, do not edit.

use rupnp::{Device, Service};
use rupnp::http::Uri;
use rupnp::ssdp::URN;use crate::sonos::gen::errors::Error;

/// Sonos SystemPropertiesService
///
/// Manage system-wide settings, mainly account stuff
#[derive(Debug)]
pub struct SystemPropertiesService {
    service: Service,
    url: Uri,
}

impl SystemPropertiesService {
    /// Create a new SystemPropertiesService instance from an existing UPnP device.
    pub async fn from_device(device: Device) -> Option<Self> {
        let urn = "urn:schemas-upnp-org:service:SystemProperties:1".parse::<URN>().unwrap();
        if let Some(s) = device.find_service(&urn) {
            Some(Self{ service: s.clone(), url: device.url().clone() })
        } else {
            None
        }
    }

    /// AddAccountX
    ///
    /// Parameters:
    /// * `account_type`
    /// * `account_id`
    /// * `account_password`
    ///
    /// Outputs:
    /// * `account_udn`
    pub async fn add_account_x(
            &self,
            account_type: u32,
            account_id: String,
            account_password: String
        ) -> Result<AddAccountXResult, Error> {
        // TODO: use xml helper
        let mut payload = String::new();
        payload.push_str(format!("<AccountType>{}</AccountType>", account_type).as_str());
        payload.push_str(format!("<AccountID>{}</AccountID>", account_id).as_str());
        payload.push_str(format!("<AccountPassword>{}</AccountPassword>", account_password).as_str());
        let response = self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        // TODO: map parse errors
        Ok(AddAccountXResult {
            account_udn: response.get("AccountUDN").ok_or_else(|| Error::MissingField("AccountUDN".to_string()))?
                .parse().map_err(|_| Error::ParseError("AccountUDN".to_string()))?,
        })
    }

    /// AddOAuthAccountX
    ///
    /// Parameters:
    /// * `account_type`
    /// * `account_token`
    /// * `account_key`
    /// * `oauth_device_id`
    /// * `authorization_code`
    /// * `redirect_uri`
    /// * `user_id_hash_code`
    /// * `account_tier`
    ///
    /// Outputs:
    /// * `account_udn`
    /// * `account_nickname`
    pub async fn add_oauth_account_x(
            &self,
            account_type: u32,
            account_token: String,
            account_key: String,
            oauth_device_id: String,
            authorization_code: String,
            redirect_uri: String,
            user_id_hash_code: String,
            account_tier: u32
        ) -> Result<AddOAuthAccountXResult, Error> {
        // TODO: use xml helper
        let mut payload = String::new();
        payload.push_str(format!("<AccountType>{}</AccountType>", account_type).as_str());
        payload.push_str(format!("<AccountToken>{}</AccountToken>", account_token).as_str());
        payload.push_str(format!("<AccountKey>{}</AccountKey>", account_key).as_str());
        payload.push_str(format!("<OAuthDeviceID>{}</OAuthDeviceID>", oauth_device_id).as_str());
        payload.push_str(format!("<AuthorizationCode>{}</AuthorizationCode>", authorization_code).as_str());
        payload.push_str(format!("<RedirectURI>{}</RedirectURI>", redirect_uri).as_str());
        payload.push_str(format!("<UserIdHashCode>{}</UserIdHashCode>", user_id_hash_code).as_str());
        payload.push_str(format!("<AccountTier>{}</AccountTier>", account_tier).as_str());
        let response = self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        // TODO: map parse errors
        Ok(AddOAuthAccountXResult {
            account_udn: response.get("AccountUDN").ok_or_else(|| Error::MissingField("AccountUDN".to_string()))?
                .parse().map_err(|_| Error::ParseError("AccountUDN".to_string()))?,
            account_nickname: response.get("AccountNickname").ok_or_else(|| Error::MissingField("AccountNickname".to_string()))?
                .parse().map_err(|_| Error::ParseError("AccountNickname".to_string()))?,
        })
    }

    /// DoPostUpdateTasks
    pub async fn do_post_update_tasks(
            &self,
        ) -> Result<(), Error> {
        let payload = String::new();
        self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        Ok(())
    }

    /// EditAccountMd
    ///
    /// Parameters:
    /// * `account_type`
    /// * `account_id`
    /// * `new_account_md`
    pub async fn edit_account_md(
            &self,
            account_type: u32,
            account_id: String,
            new_account_md: String
        ) -> Result<(), Error> {
        // TODO: use xml helper
        let mut payload = String::new();
        payload.push_str(format!("<AccountType>{}</AccountType>", account_type).as_str());
        payload.push_str(format!("<AccountID>{}</AccountID>", account_id).as_str());
        payload.push_str(format!("<NewAccountMd>{}</NewAccountMd>", new_account_md).as_str());
        self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        Ok(())
    }

    /// EditAccountPasswordX
    ///
    /// Parameters:
    /// * `account_type`
    /// * `account_id`
    /// * `new_account_password`
    pub async fn edit_account_password_x(
            &self,
            account_type: u32,
            account_id: String,
            new_account_password: String
        ) -> Result<(), Error> {
        // TODO: use xml helper
        let mut payload = String::new();
        payload.push_str(format!("<AccountType>{}</AccountType>", account_type).as_str());
        payload.push_str(format!("<AccountID>{}</AccountID>", account_id).as_str());
        payload.push_str(format!("<NewAccountPassword>{}</NewAccountPassword>", new_account_password).as_str());
        self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        Ok(())
    }

    /// EnableRDM
    ///
    /// Parameters:
    /// * `rdmvalue`
    pub async fn enable_rdm(
            &self,
            rdmvalue: bool
        ) -> Result<(), Error> {
        // TODO: use xml helper
        let mut payload = String::new();
        payload.push_str(format!("<RDMValue>{}</RDMValue>", rdmvalue).as_str());
        self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        Ok(())
    }

    /// GetRDM
    ///
    /// Outputs:
    /// * `rdmvalue`
    pub async fn get_rdm(
            &self,
        ) -> Result<GetRDMResult, Error> {
        let payload = String::new();
        let response = self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        // TODO: map parse errors
        Ok(GetRDMResult {
            rdmvalue: response.get("RDMValue").ok_or_else(|| Error::MissingField("RDMValue".to_string()))?
                .parse().map_err(|_| Error::ParseError("RDMValue".to_string()))?,
        })
    }

    /// GetString
    ///
    /// Get a saved string.
    ///
    /// Note: Strings are saved in the system with SetString, every speaker should return the same data. Will error when not existing
    ///
    /// Parameters:
    /// * `variable_name` : The key for this variable
    ///
    /// Outputs:
    /// * `string_value`
    pub async fn get_string(
            &self,
            variable_name: String
        ) -> Result<GetStringResult, Error> {
        // TODO: use xml helper
        let mut payload = String::new();
        payload.push_str(format!("<VariableName>{}</VariableName>", variable_name).as_str());
        let response = self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        // TODO: map parse errors
        Ok(GetStringResult {
            string_value: response.get("StringValue").ok_or_else(|| Error::MissingField("StringValue".to_string()))?
                .parse().map_err(|_| Error::ParseError("StringValue".to_string()))?,
        })
    }

    /// GetWebCode
    ///
    /// Parameters:
    /// * `account_type`
    ///
    /// Outputs:
    /// * `web_code`
    pub async fn get_web_code(
            &self,
            account_type: u32
        ) -> Result<GetWebCodeResult, Error> {
        // TODO: use xml helper
        let mut payload = String::new();
        payload.push_str(format!("<AccountType>{}</AccountType>", account_type).as_str());
        let response = self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        // TODO: map parse errors
        Ok(GetWebCodeResult {
            web_code: response.get("WebCode").ok_or_else(|| Error::MissingField("WebCode".to_string()))?
                .parse().map_err(|_| Error::ParseError("WebCode".to_string()))?,
        })
    }

    /// ProvisionCredentialedTrialAccountX
    ///
    /// Parameters:
    /// * `account_type`
    /// * `account_id`
    /// * `account_password`
    ///
    /// Outputs:
    /// * `is_expired`
    /// * `account_udn`
    pub async fn provision_credentialed_trial_account_x(
            &self,
            account_type: u32,
            account_id: String,
            account_password: String
        ) -> Result<ProvisionCredentialedTrialAccountXResult, Error> {
        // TODO: use xml helper
        let mut payload = String::new();
        payload.push_str(format!("<AccountType>{}</AccountType>", account_type).as_str());
        payload.push_str(format!("<AccountID>{}</AccountID>", account_id).as_str());
        payload.push_str(format!("<AccountPassword>{}</AccountPassword>", account_password).as_str());
        let response = self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        // TODO: map parse errors
        Ok(ProvisionCredentialedTrialAccountXResult {
            is_expired: response.get("IsExpired").ok_or_else(|| Error::MissingField("IsExpired".to_string()))?
                .parse().map_err(|_| Error::ParseError("IsExpired".to_string()))?,
            account_udn: response.get("AccountUDN").ok_or_else(|| Error::MissingField("AccountUDN".to_string()))?
                .parse().map_err(|_| Error::ParseError("AccountUDN".to_string()))?,
        })
    }

    /// RefreshAccountCredentialsX
    ///
    /// Parameters:
    /// * `account_type`
    /// * `account_uid`
    /// * `account_token`
    /// * `account_key`
    pub async fn refresh_account_credentials_x(
            &self,
            account_type: u32,
            account_uid: u32,
            account_token: String,
            account_key: String
        ) -> Result<(), Error> {
        // TODO: use xml helper
        let mut payload = String::new();
        payload.push_str(format!("<AccountType>{}</AccountType>", account_type).as_str());
        payload.push_str(format!("<AccountUID>{}</AccountUID>", account_uid).as_str());
        payload.push_str(format!("<AccountToken>{}</AccountToken>", account_token).as_str());
        payload.push_str(format!("<AccountKey>{}</AccountKey>", account_key).as_str());
        self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        Ok(())
    }

    /// Remove
    ///
    /// Remove a saved string
    ///
    /// Note: Not sure what happens if you call this with a VariableName that doesn't exists.
    ///
    /// Parameters:
    /// * `variable_name` : The key for this variable
    pub async fn remove(
            &self,
            variable_name: String
        ) -> Result<(), Error> {
        // TODO: use xml helper
        let mut payload = String::new();
        payload.push_str(format!("<VariableName>{}</VariableName>", variable_name).as_str());
        self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        Ok(())
    }

    /// RemoveAccount
    ///
    /// Parameters:
    /// * `account_type`
    /// * `account_id`
    pub async fn remove_account(
            &self,
            account_type: u32,
            account_id: String
        ) -> Result<(), Error> {
        // TODO: use xml helper
        let mut payload = String::new();
        payload.push_str(format!("<AccountType>{}</AccountType>", account_type).as_str());
        payload.push_str(format!("<AccountID>{}</AccountID>", account_id).as_str());
        self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        Ok(())
    }

    /// ReplaceAccountX
    ///
    /// Parameters:
    /// * `account_udn`
    /// * `new_account_id`
    /// * `new_account_password`
    /// * `account_token`
    /// * `account_key`
    /// * `oauth_device_id`
    ///
    /// Outputs:
    /// * `new_account_udn`
    pub async fn replace_account_x(
            &self,
            account_udn: String,
            new_account_id: String,
            new_account_password: String,
            account_token: String,
            account_key: String,
            oauth_device_id: String
        ) -> Result<ReplaceAccountXResult, Error> {
        // TODO: use xml helper
        let mut payload = String::new();
        payload.push_str(format!("<AccountUDN>{}</AccountUDN>", account_udn).as_str());
        payload.push_str(format!("<NewAccountID>{}</NewAccountID>", new_account_id).as_str());
        payload.push_str(format!("<NewAccountPassword>{}</NewAccountPassword>", new_account_password).as_str());
        payload.push_str(format!("<AccountToken>{}</AccountToken>", account_token).as_str());
        payload.push_str(format!("<AccountKey>{}</AccountKey>", account_key).as_str());
        payload.push_str(format!("<OAuthDeviceID>{}</OAuthDeviceID>", oauth_device_id).as_str());
        let response = self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        // TODO: map parse errors
        Ok(ReplaceAccountXResult {
            new_account_udn: response.get("NewAccountUDN").ok_or_else(|| Error::MissingField("NewAccountUDN".to_string()))?
                .parse().map_err(|_| Error::ParseError("NewAccountUDN".to_string()))?,
        })
    }

    /// ResetThirdPartyCredentials
    pub async fn reset_third_party_credentials(
            &self,
        ) -> Result<(), Error> {
        let payload = String::new();
        self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        Ok(())
    }

    /// SetAccountNicknameX
    ///
    /// Parameters:
    /// * `account_udn`
    /// * `account_nickname`
    pub async fn set_account_nickname_x(
            &self,
            account_udn: String,
            account_nickname: String
        ) -> Result<(), Error> {
        // TODO: use xml helper
        let mut payload = String::new();
        payload.push_str(format!("<AccountUDN>{}</AccountUDN>", account_udn).as_str());
        payload.push_str(format!("<AccountNickname>{}</AccountNickname>", account_nickname).as_str());
        self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        Ok(())
    }

    /// SetString
    ///
    /// Save a string in the system
    ///
    /// Note: Strings are saved in the system, retrieve values with GetString.
    ///
    /// Parameters:
    /// * `variable_name` : The key for this variable, use something unique
    /// * `string_value`
    pub async fn set_string(
            &self,
            variable_name: String,
            string_value: String
        ) -> Result<(), Error> {
        // TODO: use xml helper
        let mut payload = String::new();
        payload.push_str(format!("<VariableName>{}</VariableName>", variable_name).as_str());
        payload.push_str(format!("<StringValue>{}</StringValue>", string_value).as_str());
        self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        Ok(())
    }
}

#[derive(Debug)]
pub struct AddAccountXResult {
    pub account_udn: String,
}

#[derive(Debug)]
pub struct AddOAuthAccountXResult {
    pub account_udn: String,
    pub account_nickname: String,
}

#[derive(Debug)]
pub struct GetRDMResult {
    pub rdmvalue: bool,
}

#[derive(Debug)]
pub struct GetStringResult {
    pub string_value: String,
}

#[derive(Debug)]
pub struct GetWebCodeResult {
    pub web_code: String,
}

#[derive(Debug)]
pub struct ProvisionCredentialedTrialAccountXResult {
    pub is_expired: bool,
    pub account_udn: String,
}

#[derive(Debug)]
pub struct ReplaceAccountXResult {
    pub new_account_udn: String,
}

