// Generated by sonos-docs, do not edit.

use rupnp::{Device, Service};
use rupnp::http::Uri;
use serde_xml_rs;
use std::net::IpAddr;
use crate::sonos::gen::errors::Error;

/// Sonos SystemPropertiesService
///
/// Manage system-wide settings, mainly account stuff
#[derive(Debug)]
pub struct SystemPropertiesService {
    service: Service,
    url: Uri,
}

impl SystemPropertiesService {
    /// Create a new SystemPropertiesService instance from an existing UPnP device.
    pub async fn from_device(device: Device) -> Result<Self, Error> {
        let urn = "urn:schemas-upnp-org:service:SystemProperties:1".parse().unwrap();
        let service = device.find_service(&urn)
            .ok_or_else(|| Error::ServiceNotFound("SystemPropertiesService".to_string()))?;
        Ok(Self{ service: service.clone(), url: device.url().clone() })
    }

    /// Create a new SystemPropertiesService instance from an IP address.
    pub async fn from_ip(ip: IpAddr) -> Result<Self, Error> {
        let url = format!("http://{ip}:1400/xml/device_description.xml").parse().unwrap();
        let device = Device::from_url(url).await?;
        Self::from_device(device).await
    }

    /// AddAccountX
    ///
    /// Parameters:
    /// * `account_type`
    /// * `account_id`
    /// * `account_password`
    ///
    /// Outputs:
    /// * `account_udn`
    pub async fn add_account_x(
            &self,
            account_type: u32,
            account_id: String,
            account_password: String
        ) -> Result<AddAccountXResult, Error> {
        let payload = [
            serde_xml_rs::to_string(&account_type).unwrap(),
            serde_xml_rs::to_string(&account_id).unwrap(),
            serde_xml_rs::to_string(&account_password).unwrap(),
        ].concat();
        let response = self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        // TODO: map parse errors
        Ok(AddAccountXResult {
            account_udn: response.get("AccountUDN").ok_or_else(|| Error::MissingField("AccountUDN".to_string()))?
                .parse().map_err(|_| Error::ParseError("AccountUDN".to_string()))?,
        })
    }

    /// AddOAuthAccountX
    ///
    /// Parameters:
    /// * `account_type`
    /// * `account_token`
    /// * `account_key`
    /// * `o_auth_device_id`
    /// * `authorization_code`
    /// * `redirect_uri`
    /// * `user_id_hash_code`
    /// * `account_tier`
    ///
    /// Outputs:
    /// * `account_udn`
    /// * `account_nickname`
    pub async fn add_oauth_account_x(
            &self,
            account_type: u32,
            account_token: String,
            account_key: String,
            o_auth_device_id: String,
            authorization_code: String,
            redirect_uri: String,
            user_id_hash_code: String,
            account_tier: u32
        ) -> Result<AddOAuthAccountXResult, Error> {
        let payload = [
            serde_xml_rs::to_string(&account_type).unwrap(),
            serde_xml_rs::to_string(&account_token).unwrap(),
            serde_xml_rs::to_string(&account_key).unwrap(),
            serde_xml_rs::to_string(&o_auth_device_id).unwrap(),
            serde_xml_rs::to_string(&authorization_code).unwrap(),
            serde_xml_rs::to_string(&redirect_uri).unwrap(),
            serde_xml_rs::to_string(&user_id_hash_code).unwrap(),
            serde_xml_rs::to_string(&account_tier).unwrap(),
        ].concat();
        let response = self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        // TODO: map parse errors
        Ok(AddOAuthAccountXResult {
            account_udn: response.get("AccountUDN").ok_or_else(|| Error::MissingField("AccountUDN".to_string()))?
                .parse().map_err(|_| Error::ParseError("AccountUDN".to_string()))?,
            account_nickname: response.get("AccountNickname").ok_or_else(|| Error::MissingField("AccountNickname".to_string()))?
                .parse().map_err(|_| Error::ParseError("AccountNickname".to_string()))?,
        })
    }

    /// DoPostUpdateTasks
    pub async fn do_post_update_tasks(
            &self,
        ) -> Result<(), Error> {
        let payload = String::new();
        self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        Ok(())
    }

    /// EditAccountMd
    ///
    /// Parameters:
    /// * `account_type`
    /// * `account_id`
    /// * `new_account_md`
    pub async fn edit_account_md(
            &self,
            account_type: u32,
            account_id: String,
            new_account_md: String
        ) -> Result<(), Error> {
        let payload = [
            serde_xml_rs::to_string(&account_type).unwrap(),
            serde_xml_rs::to_string(&account_id).unwrap(),
            serde_xml_rs::to_string(&new_account_md).unwrap(),
        ].concat();
        self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        Ok(())
    }

    /// EditAccountPasswordX
    ///
    /// Parameters:
    /// * `account_type`
    /// * `account_id`
    /// * `new_account_password`
    pub async fn edit_account_password_x(
            &self,
            account_type: u32,
            account_id: String,
            new_account_password: String
        ) -> Result<(), Error> {
        let payload = [
            serde_xml_rs::to_string(&account_type).unwrap(),
            serde_xml_rs::to_string(&account_id).unwrap(),
            serde_xml_rs::to_string(&new_account_password).unwrap(),
        ].concat();
        self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        Ok(())
    }

    /// EnableRDM
    ///
    /// Parameters:
    /// * `rdm_value`
    pub async fn enable_rdm(
            &self,
            rdm_value: bool
        ) -> Result<(), Error> {
        let payload = [
            serde_xml_rs::to_string(&rdm_value).unwrap(),
        ].concat();
        self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        Ok(())
    }

    /// GetRDM
    ///
    /// Outputs:
    /// * `rdm_value`
    pub async fn get_rdm(
            &self,
        ) -> Result<GetRDMResult, Error> {
        let payload = String::new();
        let response = self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        // TODO: map parse errors
        Ok(GetRDMResult {
            rdm_value: response.get("RDMValue").ok_or_else(|| Error::MissingField("RDMValue".to_string()))?
                .parse().map_err(|_| Error::ParseError("RDMValue".to_string()))?,
        })
    }

    /// GetString
    ///
    /// Get a saved string.
    ///
    /// Note: Strings are saved in the system with SetString, every speaker should return the same data. Will error when not existing
    ///
    /// Parameters:
    /// * `variable_name` : The key for this variable
    ///
    /// Outputs:
    /// * `string_value`
    pub async fn get_string(
            &self,
            variable_name: String
        ) -> Result<GetStringResult, Error> {
        let payload = [
            serde_xml_rs::to_string(&variable_name).unwrap(),
        ].concat();
        let response = self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        // TODO: map parse errors
        Ok(GetStringResult {
            string_value: response.get("StringValue").ok_or_else(|| Error::MissingField("StringValue".to_string()))?
                .parse().map_err(|_| Error::ParseError("StringValue".to_string()))?,
        })
    }

    /// GetWebCode
    ///
    /// Parameters:
    /// * `account_type`
    ///
    /// Outputs:
    /// * `web_code`
    pub async fn get_web_code(
            &self,
            account_type: u32
        ) -> Result<GetWebCodeResult, Error> {
        let payload = [
            serde_xml_rs::to_string(&account_type).unwrap(),
        ].concat();
        let response = self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        // TODO: map parse errors
        Ok(GetWebCodeResult {
            web_code: response.get("WebCode").ok_or_else(|| Error::MissingField("WebCode".to_string()))?
                .parse().map_err(|_| Error::ParseError("WebCode".to_string()))?,
        })
    }

    /// ProvisionCredentialedTrialAccountX
    ///
    /// Parameters:
    /// * `account_type`
    /// * `account_id`
    /// * `account_password`
    ///
    /// Outputs:
    /// * `is_expired`
    /// * `account_udn`
    pub async fn provision_credentialed_trial_account_x(
            &self,
            account_type: u32,
            account_id: String,
            account_password: String
        ) -> Result<ProvisionCredentialedTrialAccountXResult, Error> {
        let payload = [
            serde_xml_rs::to_string(&account_type).unwrap(),
            serde_xml_rs::to_string(&account_id).unwrap(),
            serde_xml_rs::to_string(&account_password).unwrap(),
        ].concat();
        let response = self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        // TODO: map parse errors
        Ok(ProvisionCredentialedTrialAccountXResult {
            is_expired: response.get("IsExpired").ok_or_else(|| Error::MissingField("IsExpired".to_string()))?
                .parse().map_err(|_| Error::ParseError("IsExpired".to_string()))?,
            account_udn: response.get("AccountUDN").ok_or_else(|| Error::MissingField("AccountUDN".to_string()))?
                .parse().map_err(|_| Error::ParseError("AccountUDN".to_string()))?,
        })
    }

    /// RefreshAccountCredentialsX
    ///
    /// Parameters:
    /// * `account_type`
    /// * `account_uid`
    /// * `account_token`
    /// * `account_key`
    pub async fn refresh_account_credentials_x(
            &self,
            account_type: u32,
            account_uid: u32,
            account_token: String,
            account_key: String
        ) -> Result<(), Error> {
        let payload = [
            serde_xml_rs::to_string(&account_type).unwrap(),
            serde_xml_rs::to_string(&account_uid).unwrap(),
            serde_xml_rs::to_string(&account_token).unwrap(),
            serde_xml_rs::to_string(&account_key).unwrap(),
        ].concat();
        self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        Ok(())
    }

    /// Remove
    ///
    /// Remove a saved string
    ///
    /// Note: Not sure what happens if you call this with a VariableName that doesn't exists.
    ///
    /// Parameters:
    /// * `variable_name` : The key for this variable
    pub async fn remove(
            &self,
            variable_name: String
        ) -> Result<(), Error> {
        let payload = [
            serde_xml_rs::to_string(&variable_name).unwrap(),
        ].concat();
        self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        Ok(())
    }

    /// RemoveAccount
    ///
    /// Parameters:
    /// * `account_type`
    /// * `account_id`
    pub async fn remove_account(
            &self,
            account_type: u32,
            account_id: String
        ) -> Result<(), Error> {
        let payload = [
            serde_xml_rs::to_string(&account_type).unwrap(),
            serde_xml_rs::to_string(&account_id).unwrap(),
        ].concat();
        self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        Ok(())
    }

    /// ReplaceAccountX
    ///
    /// Parameters:
    /// * `account_udn`
    /// * `new_account_id`
    /// * `new_account_password`
    /// * `account_token`
    /// * `account_key`
    /// * `o_auth_device_id`
    ///
    /// Outputs:
    /// * `new_account_udn`
    pub async fn replace_account_x(
            &self,
            account_udn: String,
            new_account_id: String,
            new_account_password: String,
            account_token: String,
            account_key: String,
            o_auth_device_id: String
        ) -> Result<ReplaceAccountXResult, Error> {
        let payload = [
            serde_xml_rs::to_string(&account_udn).unwrap(),
            serde_xml_rs::to_string(&new_account_id).unwrap(),
            serde_xml_rs::to_string(&new_account_password).unwrap(),
            serde_xml_rs::to_string(&account_token).unwrap(),
            serde_xml_rs::to_string(&account_key).unwrap(),
            serde_xml_rs::to_string(&o_auth_device_id).unwrap(),
        ].concat();
        let response = self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        // TODO: map parse errors
        Ok(ReplaceAccountXResult {
            new_account_udn: response.get("NewAccountUDN").ok_or_else(|| Error::MissingField("NewAccountUDN".to_string()))?
                .parse().map_err(|_| Error::ParseError("NewAccountUDN".to_string()))?,
        })
    }

    /// ResetThirdPartyCredentials
    pub async fn reset_third_party_credentials(
            &self,
        ) -> Result<(), Error> {
        let payload = String::new();
        self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        Ok(())
    }

    /// SetAccountNicknameX
    ///
    /// Parameters:
    /// * `account_udn`
    /// * `account_nickname`
    pub async fn set_account_nickname_x(
            &self,
            account_udn: String,
            account_nickname: String
        ) -> Result<(), Error> {
        let payload = [
            serde_xml_rs::to_string(&account_udn).unwrap(),
            serde_xml_rs::to_string(&account_nickname).unwrap(),
        ].concat();
        self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        Ok(())
    }

    /// SetString
    ///
    /// Save a string in the system
    ///
    /// Note: Strings are saved in the system, retrieve values with GetString.
    ///
    /// Parameters:
    /// * `variable_name` : The key for this variable, use something unique
    /// * `string_value`
    pub async fn set_string(
            &self,
            variable_name: String,
            string_value: String
        ) -> Result<(), Error> {
        let payload = [
            serde_xml_rs::to_string(&variable_name).unwrap(),
            serde_xml_rs::to_string(&string_value).unwrap(),
        ].concat();
        self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        Ok(())
    }
}

#[derive(Debug)]
pub struct AddAccountXResult {
    pub account_udn: String,
}

#[derive(Debug)]
pub struct AddOAuthAccountXResult {
    pub account_udn: String,
    pub account_nickname: String,
}

#[derive(Debug)]
pub struct GetRDMResult {
    pub rdm_value: bool,
}

#[derive(Debug)]
pub struct GetStringResult {
    pub string_value: String,
}

#[derive(Debug)]
pub struct GetWebCodeResult {
    pub web_code: String,
}

#[derive(Debug)]
pub struct ProvisionCredentialedTrialAccountXResult {
    pub is_expired: bool,
    pub account_udn: String,
}

#[derive(Debug)]
pub struct ReplaceAccountXResult {
    pub new_account_udn: String,
}

