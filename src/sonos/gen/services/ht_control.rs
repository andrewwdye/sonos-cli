// Generated by sonos-docs, do not edit.

use rupnp::{Device, Service};
use rupnp::http::Uri;
use rupnp::ssdp::URN;use crate::sonos::gen::errors::Error;

/// Sonos HTControlService
///
/// Service related to the TV remote control
#[derive(Debug)]
pub struct HTControlService {
    service: Service,
    url: Uri,
}

impl HTControlService {
    /// Create a new HTControlService instance from an existing UPnP device.
    pub async fn from_device(device: Device) -> Option<Self> {
        let urn = "urn:schemas-upnp-org:service:HTControl:1".parse::<URN>().unwrap();
        if let Some(s) = device.find_service(&urn) {
            Some(Self{ service: s.clone(), url: device.url().clone() })
        } else {
            None
        }
    }

    /// CommitLearnedIRCodes
    ///
    /// Parameters:
    /// * `name`
    pub async fn commit_learned_ircodes(
            &self,
            name: String
        ) -> Result<(), Error> {
        // TODO: use xml helper
        let mut payload = String::new();
        payload.push_str(format!("<Name>{}</Name>", name).as_str());
        self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        Ok(())
    }

    /// GetIRRepeaterState
    ///
    /// Outputs:
    /// * `current_irrepeater_state`
    pub async fn get_irrepeater_state(
            &self,
        ) -> Result<GetIRRepeaterStateResult, Error> {
        let payload = String::new();
        let response = self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        // TODO: map parse errors
        Ok(GetIRRepeaterStateResult {
            current_irrepeater_state: response.get("CurrentIRRepeaterState").ok_or_else(|| Error::MissingField("CurrentIRRepeaterState".to_string()))?
                .parse().map_err(|_| Error::ParseError("CurrentIRRepeaterState".to_string()))?,
        })
    }

    /// GetLEDFeedbackState
    ///
    /// Outputs:
    /// * `led_feedback_state`
    pub async fn get_ledfeedback_state(
            &self,
        ) -> Result<GetLEDFeedbackStateResult, Error> {
        let payload = String::new();
        let response = self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        // TODO: map parse errors
        Ok(GetLEDFeedbackStateResult {
            led_feedback_state: response.get("LEDFeedbackState").ok_or_else(|| Error::MissingField("LEDFeedbackState".to_string()))?
                .parse().map_err(|_| Error::ParseError("LEDFeedbackState".to_string()))?,
        })
    }

    /// IdentifyIRRemote
    ///
    /// Parameters:
    /// * `timeout`
    pub async fn identify_irremote(
            &self,
            timeout: u32
        ) -> Result<(), Error> {
        // TODO: use xml helper
        let mut payload = String::new();
        payload.push_str(format!("<Timeout>{}</Timeout>", timeout).as_str());
        self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        Ok(())
    }

    /// IsRemoteConfigured
    ///
    /// Outputs:
    /// * `remote_configured`
    pub async fn is_remote_configured(
            &self,
        ) -> Result<IsRemoteConfiguredResult, Error> {
        let payload = String::new();
        let response = self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        // TODO: map parse errors
        Ok(IsRemoteConfiguredResult {
            remote_configured: response.get("RemoteConfigured").ok_or_else(|| Error::MissingField("RemoteConfigured".to_string()))?
                .parse().map_err(|_| Error::ParseError("RemoteConfigured".to_string()))?,
        })
    }

    /// LearnIRCode
    ///
    /// Parameters:
    /// * `ir_code`
    /// * `timeout`
    pub async fn learn_ircode(
            &self,
            ir_code: String,
            timeout: u32
        ) -> Result<(), Error> {
        // TODO: use xml helper
        let mut payload = String::new();
        payload.push_str(format!("<IRCode>{}</IRCode>", ir_code).as_str());
        payload.push_str(format!("<Timeout>{}</Timeout>", timeout).as_str());
        self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        Ok(())
    }

    /// SetIRRepeaterState
    ///
    /// Parameters:
    /// * `desired_irrepeater_state`
    pub async fn set_irrepeater_state(
            &self,
            desired_irrepeater_state: String
        ) -> Result<(), Error> {
        // TODO: use xml helper
        let mut payload = String::new();
        payload.push_str(format!("<DesiredIRRepeaterState>{}</DesiredIRRepeaterState>", desired_irrepeater_state).as_str());
        self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        Ok(())
    }

    /// SetLEDFeedbackState
    ///
    /// Parameters:
    /// * `led_feedback_state`
    pub async fn set_ledfeedback_state(
            &self,
            led_feedback_state: String
        ) -> Result<(), Error> {
        // TODO: use xml helper
        let mut payload = String::new();
        payload.push_str(format!("<LEDFeedbackState>{}</LEDFeedbackState>", led_feedback_state).as_str());
        self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        Ok(())
    }
}

#[derive(Debug)]
pub struct GetIRRepeaterStateResult {
    pub current_irrepeater_state: String,
}

#[derive(Debug)]
pub struct GetLEDFeedbackStateResult {
    pub led_feedback_state: String,
}

#[derive(Debug)]
pub struct IsRemoteConfiguredResult {
    pub remote_configured: bool,
}

