// Generated by sonos-docs, do not edit.

use rupnp::{Device, Service};
use rupnp::http::Uri;
use rupnp::ssdp::URN;
use serde_xml_rs;
use std::net::IpAddr;
use crate::sonos::gen::errors::Error;

/// Sonos HTControlService
///
/// Service related to the TV remote control
#[derive(Debug)]
pub struct HTControlService {
    service: Service,
    url: Uri,
}

impl HTControlService {
    /// Create a new HTControlService instance from an existing UPnP device.
    async fn from_device(device: Device) -> Result<Self, Error> {
        let urn = "urn:schemas-upnp-org:service:urn:schemas-upnp-org:service:HTControl:1:1".parse::<URN>().unwrap();
        let service = device.find_service(&urn)
            .ok_or_else(|| Error::ServiceNotFound("HTControlService".to_string()))?;
        Ok(Self{ service: service.clone(), url: device.url().clone() })
    }

    /// Create a new HTControlService instance from an IP address.
    async fn from_ip(ip: IpAddr) -> Result<Self, Error> {
        let url = Uri::from_str(format!("http://{ip}:1400/xml/device_description.xml").as_str()).unwrap();
        let device = Device::from_url(url).await?;
        Self::from_device(device).await
    }

    /// CommitLearnedIRCodes
    ///
    /// Parameters:
    /// * `name`
    pub async fn commit_learned_ircodes(
            &self,
            name: String
        ) -> Result<(), Error> {
        let payload = [
            serde_xml_rs::to_string(&name).unwrap(),
        ].concat();
        self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        Ok(())
    }

    /// GetIRRepeaterState
    ///
    /// Outputs:
    /// * `current_irrepeater_state`
    pub async fn get_irrepeater_state(
            &self,
        ) -> Result<GetIRRepeaterStateResult, Error> {
        let payload = String::new();
        let response = self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        // TODO: map parse errors
        Ok(GetIRRepeaterStateResult {
            current_irrepeater_state: response.get("CurrentIRRepeaterState").ok_or_else(|| Error::MissingField("CurrentIRRepeaterState".to_string()))?
                .parse().map_err(|_| Error::ParseError("CurrentIRRepeaterState".to_string()))?,
        })
    }

    /// GetLEDFeedbackState
    ///
    /// Outputs:
    /// * `led_feedback_state`
    pub async fn get_ledfeedback_state(
            &self,
        ) -> Result<GetLEDFeedbackStateResult, Error> {
        let payload = String::new();
        let response = self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        // TODO: map parse errors
        Ok(GetLEDFeedbackStateResult {
            led_feedback_state: response.get("LEDFeedbackState").ok_or_else(|| Error::MissingField("LEDFeedbackState".to_string()))?
                .parse().map_err(|_| Error::ParseError("LEDFeedbackState".to_string()))?,
        })
    }

    /// IdentifyIRRemote
    ///
    /// Parameters:
    /// * `timeout`
    pub async fn identify_irremote(
            &self,
            timeout: u32
        ) -> Result<(), Error> {
        let payload = [
            serde_xml_rs::to_string(&timeout).unwrap(),
        ].concat();
        self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        Ok(())
    }

    /// IsRemoteConfigured
    ///
    /// Outputs:
    /// * `remote_configured`
    pub async fn is_remote_configured(
            &self,
        ) -> Result<IsRemoteConfiguredResult, Error> {
        let payload = String::new();
        let response = self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        // TODO: map parse errors
        Ok(IsRemoteConfiguredResult {
            remote_configured: response.get("RemoteConfigured").ok_or_else(|| Error::MissingField("RemoteConfigured".to_string()))?
                .parse().map_err(|_| Error::ParseError("RemoteConfigured".to_string()))?,
        })
    }

    /// LearnIRCode
    ///
    /// Parameters:
    /// * `ir_code`
    /// * `timeout`
    pub async fn learn_ircode(
            &self,
            ir_code: String,
            timeout: u32
        ) -> Result<(), Error> {
        let payload = [
            serde_xml_rs::to_string(&ir_code).unwrap(),
            serde_xml_rs::to_string(&timeout).unwrap(),
        ].concat();
        self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        Ok(())
    }

    /// SetIRRepeaterState
    ///
    /// Parameters:
    /// * `desired_irrepeater_state`
    pub async fn set_irrepeater_state(
            &self,
            desired_irrepeater_state: String
        ) -> Result<(), Error> {
        let payload = [
            serde_xml_rs::to_string(&desired_irrepeater_state).unwrap(),
        ].concat();
        self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        Ok(())
    }

    /// SetLEDFeedbackState
    ///
    /// Parameters:
    /// * `led_feedback_state`
    pub async fn set_ledfeedback_state(
            &self,
            led_feedback_state: String
        ) -> Result<(), Error> {
        let payload = [
            serde_xml_rs::to_string(&led_feedback_state).unwrap(),
        ].concat();
        self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        Ok(())
    }
}

#[derive(Debug)]
pub struct GetIRRepeaterStateResult {
    pub current_irrepeater_state: String,
}

#[derive(Debug)]
pub struct GetLEDFeedbackStateResult {
    pub led_feedback_state: String,
}

#[derive(Debug)]
pub struct IsRemoteConfiguredResult {
    pub remote_configured: bool,
}

