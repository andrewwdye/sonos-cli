// Generated by sonos-docs, do not edit.

use rupnp::{Device, Service};
use rupnp::http::Uri;
use rupnp::ssdp::URN;use crate::sonos::gen::errors::Error;
use serde_xml_rs;

/// Sonos GroupRenderingControlService
///
/// Volume related controls for groups
#[derive(Debug)]
pub struct GroupRenderingControlService {
    service: Service,
    url: Uri,
}

impl GroupRenderingControlService {
    /// Create a new GroupRenderingControlService instance from an existing UPnP device.
    pub async fn from_device(device: Device) -> Option<Self> {
        let urn = "urn:schemas-upnp-org:service:GroupRenderingControl:1".parse::<URN>().unwrap();
        if let Some(s) = device.find_service(&urn) {
            Some(Self{ service: s.clone(), url: device.url().clone() })
        } else {
            None
        }
    }

    /// GetGroupMute
    ///
    /// Get the group mute state.
    ///
    /// Note: Should be send to coordinator only
    ///
    /// Parameters:
    /// * `instance_id` : InstanceID should always be `0`
    ///
    /// Outputs:
    /// * `current_mute`
    pub async fn get_group_mute(
            &self,
            instance_id: u32
        ) -> Result<GetGroupMuteResult, Error> {
        let payload = [
            serde_xml_rs::to_string(&instance_id).unwrap(),
        ].concat();
        let response = self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        // TODO: map parse errors
        Ok(GetGroupMuteResult {
            current_mute: response.get("CurrentMute").ok_or_else(|| Error::MissingField("CurrentMute".to_string()))?
                .parse().map_err(|_| Error::ParseError("CurrentMute".to_string()))?,
        })
    }

    /// GetGroupVolume
    ///
    /// Get the group volume.
    ///
    /// Note: Should be send to coordinator only
    ///
    /// Parameters:
    /// * `instance_id` : InstanceID should always be `0`
    ///
    /// Outputs:
    /// * `current_volume`
    pub async fn get_group_volume(
            &self,
            instance_id: u32
        ) -> Result<GetGroupVolumeResult, Error> {
        let payload = [
            serde_xml_rs::to_string(&instance_id).unwrap(),
        ].concat();
        let response = self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        // TODO: map parse errors
        Ok(GetGroupVolumeResult {
            current_volume: response.get("CurrentVolume").ok_or_else(|| Error::MissingField("CurrentVolume".to_string()))?
                .parse().map_err(|_| Error::ParseError("CurrentVolume".to_string()))?,
        })
    }

    /// SetGroupMute
    ///
    /// (Un-/)Mute the entire group
    ///
    /// Note: Should be send to coordinator only
    ///
    /// Parameters:
    /// * `instance_id` : InstanceID should always be `0`
    /// * `desired_mute`
    pub async fn set_group_mute(
            &self,
            instance_id: u32,
            desired_mute: bool
        ) -> Result<(), Error> {
        let payload = [
            serde_xml_rs::to_string(&instance_id).unwrap(),
            serde_xml_rs::to_string(&desired_mute).unwrap(),
        ].concat();
        self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        Ok(())
    }

    /// SetGroupVolume
    ///
    /// Change group volume. Players volume will be changed proportionally based on last snapshot
    ///
    /// Note: Should be send to coordinator only
    ///
    /// Parameters:
    /// * `instance_id` : InstanceID should always be `0`
    /// * `desired_volume` : New volume between 0 and 100
    pub async fn set_group_volume(
            &self,
            instance_id: u32,
            desired_volume: u16
        ) -> Result<(), Error> {
        let payload = [
            serde_xml_rs::to_string(&instance_id).unwrap(),
            serde_xml_rs::to_string(&desired_volume).unwrap(),
        ].concat();
        self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        Ok(())
    }

    /// SetRelativeGroupVolume
    ///
    /// Relatively change group volume - returns final group volume. Players volume will be changed proportionally based on last snapshot
    ///
    /// Note: Should be send to coordinator only
    ///
    /// Parameters:
    /// * `instance_id` : InstanceID should always be `0`
    /// * `adjustment` : Number between -100 and +100
    ///
    /// Outputs:
    /// * `new_volume`
    pub async fn set_relative_group_volume(
            &self,
            instance_id: u32,
            adjustment: i32
        ) -> Result<SetRelativeGroupVolumeResult, Error> {
        let payload = [
            serde_xml_rs::to_string(&instance_id).unwrap(),
            serde_xml_rs::to_string(&adjustment).unwrap(),
        ].concat();
        let response = self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        // TODO: map parse errors
        Ok(SetRelativeGroupVolumeResult {
            new_volume: response.get("NewVolume").ok_or_else(|| Error::MissingField("NewVolume".to_string()))?
                .parse().map_err(|_| Error::ParseError("NewVolume".to_string()))?,
        })
    }

    /// SnapshotGroupVolume
    ///
    /// Creates a new group volume snapshot,  the volume ratio between all players. It is used by SetGroupVolume and SetRelativeGroupVolume
    ///
    /// Note: Should be send to coordinator only
    ///
    /// Parameters:
    /// * `instance_id` : InstanceID should always be `0`
    pub async fn snapshot_group_volume(
            &self,
            instance_id: u32
        ) -> Result<(), Error> {
        let payload = [
            serde_xml_rs::to_string(&instance_id).unwrap(),
        ].concat();
        self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        Ok(())
    }
}

#[derive(Debug)]
pub struct GetGroupMuteResult {
    pub current_mute: bool,
}

#[derive(Debug)]
pub struct GetGroupVolumeResult {
    pub current_volume: u16,
}

#[derive(Debug)]
pub struct SetRelativeGroupVolumeResult {
    pub new_volume: u16,
}

