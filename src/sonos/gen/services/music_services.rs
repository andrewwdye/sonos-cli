// Generated by sonos-docs, do not edit.

use rupnp::{Device, Service};
use rupnp::http::Uri;
use rupnp::ssdp::URN;use crate::sonos::gen::errors::Error;
use serde_xml_rs;

/// Sonos MusicServicesService
///
/// Access to external music services, like Spotify or Youtube Music
#[derive(Debug)]
pub struct MusicServicesService {
    service: Service,
    url: Uri,
}

impl MusicServicesService {
    /// Create a new MusicServicesService instance from an existing UPnP device.
    pub async fn from_device(device: Device) -> Option<Self> {
        let urn = "urn:schemas-upnp-org:service:MusicServices:1".parse::<URN>().unwrap();
        if let Some(s) = device.find_service(&urn) {
            Some(Self{ service: s.clone(), url: device.url().clone() })
        } else {
            None
        }
    }

    /// GetSessionId
    ///
    /// Parameters:
    /// * `service_id`
    /// * `username`
    ///
    /// Outputs:
    /// * `session_id`
    pub async fn get_session_id(
            &self,
            service_id: u32,
            username: String
        ) -> Result<GetSessionIdResult, Error> {
        let payload = [
            serde_xml_rs::to_string(&service_id).unwrap(),
            serde_xml_rs::to_string(&username).unwrap(),
        ].concat();
        let response = self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        // TODO: map parse errors
        Ok(GetSessionIdResult {
            session_id: response.get("SessionId").ok_or_else(|| Error::MissingField("SessionId".to_string()))?
                .parse().map_err(|_| Error::ParseError("SessionId".to_string()))?,
        })
    }

    /// ListAvailableServices
    ///
    /// Load music service list as xml
    ///
    /// Note: Some libraries also support ListAndParseAvailableServices
    ///
    /// Outputs:
    /// * `available_service_descriptor_list`
    /// * `available_service_type_list`
    /// * `available_service_list_version`
    pub async fn list_available_services(
            &self,
        ) -> Result<ListAvailableServicesResult, Error> {
        let payload = String::new();
        let response = self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        // TODO: map parse errors
        Ok(ListAvailableServicesResult {
            available_service_descriptor_list: response.get("AvailableServiceDescriptorList").ok_or_else(|| Error::MissingField("AvailableServiceDescriptorList".to_string()))?
                .parse().map_err(|_| Error::ParseError("AvailableServiceDescriptorList".to_string()))?,
            available_service_type_list: response.get("AvailableServiceTypeList").ok_or_else(|| Error::MissingField("AvailableServiceTypeList".to_string()))?
                .parse().map_err(|_| Error::ParseError("AvailableServiceTypeList".to_string()))?,
            available_service_list_version: response.get("AvailableServiceListVersion").ok_or_else(|| Error::MissingField("AvailableServiceListVersion".to_string()))?
                .parse().map_err(|_| Error::ParseError("AvailableServiceListVersion".to_string()))?,
        })
    }

    /// UpdateAvailableServices
    pub async fn update_available_services(
            &self,
        ) -> Result<(), Error> {
        let payload = String::new();
        self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        Ok(())
    }
}

#[derive(Debug)]
pub struct GetSessionIdResult {
    pub session_id: String,
}

#[derive(Debug)]
pub struct ListAvailableServicesResult {
    pub available_service_descriptor_list: String,
    pub available_service_type_list: String,
    pub available_service_list_version: String,
}

