// Generated by sonos-docs, do not edit.

use rupnp::{Device, Service};
use rupnp::http::Uri;
use rupnp::ssdp::URN;use crate::sonos::gen::errors::Error;

/// Sonos AVTransportService
///
/// Service that controls stuff related to transport (play/pause/next/special URLs)
#[derive(Debug)]
pub struct AVTransportService {
    service: Service,
    url: Uri,
}

impl AVTransportService {
    /// Create a new AVTransportService instance from an existing UPnP device.
    pub async fn from_device(device: Device) -> Option<Self> {
        let urn = "urn:schemas-upnp-org:service:AVTransport:1".parse::<URN>().unwrap();
        if let Some(s) = device.find_service(&urn) {
            Some(Self{ service: s.clone(), url: device.url().clone() })
        } else {
            None
        }
    }

    /// AddMultipleURIsToQueue
    ///
    /// Parameters:
    /// * `instance_id` : InstanceID should always be `0`
    /// * `update_id`
    /// * `number_of_uris`
    /// * `enqueued_uris`
    /// * `enqueued_uris_meta_data`
    /// * `container_uri`
    /// * `container_meta_data`
    /// * `desired_first_track_number_enqueued`
    /// * `enqueue_as_next`
    ///
    /// Outputs:
    /// * `first_track_number_enqueued`
    /// * `num_tracks_added`
    /// * `new_queue_length`
    /// * `new_update_id`
    pub async fn add_multiple_uris_to_queue(
            &self,
            instance_id: u32,
            update_id: u32,
            number_of_uris: u32,
            enqueued_uris: String,
            enqueued_uris_meta_data: String,
            container_uri: String,
            container_meta_data: String,
            desired_first_track_number_enqueued: u32,
            enqueue_as_next: bool
        ) -> Result<AddMultipleURIsToQueueResult, Error> {
        // TODO: use xml helper
        let mut payload = String::new();
        payload.push_str(format!("<InstanceID>{}</InstanceID>", instance_id).as_str());
        payload.push_str(format!("<UpdateID>{}</UpdateID>", update_id).as_str());
        payload.push_str(format!("<NumberOfURIs>{}</NumberOfURIs>", number_of_uris).as_str());
        payload.push_str(format!("<EnqueuedURIs>{}</EnqueuedURIs>", enqueued_uris).as_str());
        payload.push_str(format!("<EnqueuedURIsMetaData>{}</EnqueuedURIsMetaData>", enqueued_uris_meta_data).as_str());
        payload.push_str(format!("<ContainerURI>{}</ContainerURI>", container_uri).as_str());
        payload.push_str(format!("<ContainerMetaData>{}</ContainerMetaData>", container_meta_data).as_str());
        payload.push_str(format!("<DesiredFirstTrackNumberEnqueued>{}</DesiredFirstTrackNumberEnqueued>", desired_first_track_number_enqueued).as_str());
        payload.push_str(format!("<EnqueueAsNext>{}</EnqueueAsNext>", enqueue_as_next).as_str());
        let response = self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        // TODO: map parse errors
        Ok(AddMultipleURIsToQueueResult {
            first_track_number_enqueued: response.get("FirstTrackNumberEnqueued").ok_or_else(|| Error::MissingField("FirstTrackNumberEnqueued".to_string()))?
                .parse().map_err(|_| Error::ParseError("FirstTrackNumberEnqueued".to_string()))?,
            num_tracks_added: response.get("NumTracksAdded").ok_or_else(|| Error::MissingField("NumTracksAdded".to_string()))?
                .parse().map_err(|_| Error::ParseError("NumTracksAdded".to_string()))?,
            new_queue_length: response.get("NewQueueLength").ok_or_else(|| Error::MissingField("NewQueueLength".to_string()))?
                .parse().map_err(|_| Error::ParseError("NewQueueLength".to_string()))?,
            new_update_id: response.get("NewUpdateID").ok_or_else(|| Error::MissingField("NewUpdateID".to_string()))?
                .parse().map_err(|_| Error::ParseError("NewUpdateID".to_string()))?,
        })
    }

    /// AddURIToQueue
    ///
    /// Adds songs to the SONOS queue
    ///
    /// Note: In NORMAL play mode the songs are added prior to the specified `DesiredFirstTrackNumberEnqueued`.
    ///
    /// Parameters:
    /// * `instance_id` : InstanceID should always be `0`
    /// * `enqueued_uri`
    /// * `enqueued_urimeta_data`
    /// * `desired_first_track_number_enqueued` : use `0` to add at the end or `1` to insert at the beginning
    /// * `enqueue_as_next`
    ///
    /// Outputs:
    /// * `first_track_number_enqueued`
    /// * `num_tracks_added`
    /// * `new_queue_length`
    pub async fn add_urito_queue(
            &self,
            instance_id: u32,
            enqueued_uri: String,
            enqueued_urimeta_data: String,
            desired_first_track_number_enqueued: u32,
            enqueue_as_next: bool
        ) -> Result<AddURIToQueueResult, Error> {
        // TODO: use xml helper
        let mut payload = String::new();
        payload.push_str(format!("<InstanceID>{}</InstanceID>", instance_id).as_str());
        payload.push_str(format!("<EnqueuedURI>{}</EnqueuedURI>", enqueued_uri).as_str());
        payload.push_str(format!("<EnqueuedURIMetaData>{}</EnqueuedURIMetaData>", enqueued_urimeta_data).as_str());
        payload.push_str(format!("<DesiredFirstTrackNumberEnqueued>{}</DesiredFirstTrackNumberEnqueued>", desired_first_track_number_enqueued).as_str());
        payload.push_str(format!("<EnqueueAsNext>{}</EnqueueAsNext>", enqueue_as_next).as_str());
        let response = self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        // TODO: map parse errors
        Ok(AddURIToQueueResult {
            first_track_number_enqueued: response.get("FirstTrackNumberEnqueued").ok_or_else(|| Error::MissingField("FirstTrackNumberEnqueued".to_string()))?
                .parse().map_err(|_| Error::ParseError("FirstTrackNumberEnqueued".to_string()))?,
            num_tracks_added: response.get("NumTracksAdded").ok_or_else(|| Error::MissingField("NumTracksAdded".to_string()))?
                .parse().map_err(|_| Error::ParseError("NumTracksAdded".to_string()))?,
            new_queue_length: response.get("NewQueueLength").ok_or_else(|| Error::MissingField("NewQueueLength".to_string()))?
                .parse().map_err(|_| Error::ParseError("NewQueueLength".to_string()))?,
        })
    }

    /// AddURIToSavedQueue
    ///
    /// Parameters:
    /// * `instance_id` : InstanceID should always be `0`
    /// * `object_id`
    /// * `update_id`
    /// * `enqueued_uri`
    /// * `enqueued_urimeta_data`
    /// * `add_at_index`
    ///
    /// Outputs:
    /// * `num_tracks_added`
    /// * `new_queue_length`
    /// * `new_update_id`
    pub async fn add_urito_saved_queue(
            &self,
            instance_id: u32,
            object_id: String,
            update_id: u32,
            enqueued_uri: String,
            enqueued_urimeta_data: String,
            add_at_index: u32
        ) -> Result<AddURIToSavedQueueResult, Error> {
        // TODO: use xml helper
        let mut payload = String::new();
        payload.push_str(format!("<InstanceID>{}</InstanceID>", instance_id).as_str());
        payload.push_str(format!("<ObjectID>{}</ObjectID>", object_id).as_str());
        payload.push_str(format!("<UpdateID>{}</UpdateID>", update_id).as_str());
        payload.push_str(format!("<EnqueuedURI>{}</EnqueuedURI>", enqueued_uri).as_str());
        payload.push_str(format!("<EnqueuedURIMetaData>{}</EnqueuedURIMetaData>", enqueued_urimeta_data).as_str());
        payload.push_str(format!("<AddAtIndex>{}</AddAtIndex>", add_at_index).as_str());
        let response = self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        // TODO: map parse errors
        Ok(AddURIToSavedQueueResult {
            num_tracks_added: response.get("NumTracksAdded").ok_or_else(|| Error::MissingField("NumTracksAdded".to_string()))?
                .parse().map_err(|_| Error::ParseError("NumTracksAdded".to_string()))?,
            new_queue_length: response.get("NewQueueLength").ok_or_else(|| Error::MissingField("NewQueueLength".to_string()))?
                .parse().map_err(|_| Error::ParseError("NewQueueLength".to_string()))?,
            new_update_id: response.get("NewUpdateID").ok_or_else(|| Error::MissingField("NewUpdateID".to_string()))?
                .parse().map_err(|_| Error::ParseError("NewUpdateID".to_string()))?,
        })
    }

    /// BackupQueue
    ///
    /// Parameters:
    /// * `instance_id` : InstanceID should always be `0`
    pub async fn backup_queue(
            &self,
            instance_id: u32
        ) -> Result<(), Error> {
        // TODO: use xml helper
        let mut payload = String::new();
        payload.push_str(format!("<InstanceID>{}</InstanceID>", instance_id).as_str());
        self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        Ok(())
    }

    /// BecomeCoordinatorOfStandaloneGroup
    ///
    /// Leave the current group and revert to a single player.
    ///
    /// Parameters:
    /// * `instance_id` : InstanceID should always be `0`
    ///
    /// Outputs:
    /// * `delegated_group_coordinator_id`
    /// * `new_group_id`
    pub async fn become_coordinator_of_standalone_group(
            &self,
            instance_id: u32
        ) -> Result<BecomeCoordinatorOfStandaloneGroupResult, Error> {
        // TODO: use xml helper
        let mut payload = String::new();
        payload.push_str(format!("<InstanceID>{}</InstanceID>", instance_id).as_str());
        let response = self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        // TODO: map parse errors
        Ok(BecomeCoordinatorOfStandaloneGroupResult {
            delegated_group_coordinator_id: response.get("DelegatedGroupCoordinatorID").ok_or_else(|| Error::MissingField("DelegatedGroupCoordinatorID".to_string()))?
                .parse().map_err(|_| Error::ParseError("DelegatedGroupCoordinatorID".to_string()))?,
            new_group_id: response.get("NewGroupID").ok_or_else(|| Error::MissingField("NewGroupID".to_string()))?
                .parse().map_err(|_| Error::ParseError("NewGroupID".to_string()))?,
        })
    }

    /// BecomeGroupCoordinator
    ///
    /// Parameters:
    /// * `instance_id` : InstanceID should always be `0`
    /// * `current_coordinator`
    /// * `current_group_id`
    /// * `other_members`
    /// * `transport_settings`
    /// * `current_uri`
    /// * `current_urimeta_data`
    /// * `sleep_timer_state`
    /// * `alarm_state`
    /// * `stream_restart_state`
    /// * `current_queue_track_list`
    /// * `current_vlistate`
    pub async fn become_group_coordinator(
            &self,
            instance_id: u32,
            current_coordinator: String,
            current_group_id: String,
            other_members: String,
            transport_settings: String,
            current_uri: String,
            current_urimeta_data: String,
            sleep_timer_state: String,
            alarm_state: String,
            stream_restart_state: String,
            current_queue_track_list: String,
            current_vlistate: String
        ) -> Result<(), Error> {
        // TODO: use xml helper
        let mut payload = String::new();
        payload.push_str(format!("<InstanceID>{}</InstanceID>", instance_id).as_str());
        payload.push_str(format!("<CurrentCoordinator>{}</CurrentCoordinator>", current_coordinator).as_str());
        payload.push_str(format!("<CurrentGroupID>{}</CurrentGroupID>", current_group_id).as_str());
        payload.push_str(format!("<OtherMembers>{}</OtherMembers>", other_members).as_str());
        payload.push_str(format!("<TransportSettings>{}</TransportSettings>", transport_settings).as_str());
        payload.push_str(format!("<CurrentURI>{}</CurrentURI>", current_uri).as_str());
        payload.push_str(format!("<CurrentURIMetaData>{}</CurrentURIMetaData>", current_urimeta_data).as_str());
        payload.push_str(format!("<SleepTimerState>{}</SleepTimerState>", sleep_timer_state).as_str());
        payload.push_str(format!("<AlarmState>{}</AlarmState>", alarm_state).as_str());
        payload.push_str(format!("<StreamRestartState>{}</StreamRestartState>", stream_restart_state).as_str());
        payload.push_str(format!("<CurrentQueueTrackList>{}</CurrentQueueTrackList>", current_queue_track_list).as_str());
        payload.push_str(format!("<CurrentVLIState>{}</CurrentVLIState>", current_vlistate).as_str());
        self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        Ok(())
    }

    /// BecomeGroupCoordinatorAndSource
    ///
    /// Parameters:
    /// * `instance_id` : InstanceID should always be `0`
    /// * `current_coordinator`
    /// * `current_group_id`
    /// * `other_members`
    /// * `current_uri`
    /// * `current_urimeta_data`
    /// * `sleep_timer_state`
    /// * `alarm_state`
    /// * `stream_restart_state`
    /// * `current_avttrack_list`
    /// * `current_queue_track_list`
    /// * `current_source_state`
    /// * `resume_playback`
    pub async fn become_group_coordinator_and_source(
            &self,
            instance_id: u32,
            current_coordinator: String,
            current_group_id: String,
            other_members: String,
            current_uri: String,
            current_urimeta_data: String,
            sleep_timer_state: String,
            alarm_state: String,
            stream_restart_state: String,
            current_avttrack_list: String,
            current_queue_track_list: String,
            current_source_state: String,
            resume_playback: bool
        ) -> Result<(), Error> {
        // TODO: use xml helper
        let mut payload = String::new();
        payload.push_str(format!("<InstanceID>{}</InstanceID>", instance_id).as_str());
        payload.push_str(format!("<CurrentCoordinator>{}</CurrentCoordinator>", current_coordinator).as_str());
        payload.push_str(format!("<CurrentGroupID>{}</CurrentGroupID>", current_group_id).as_str());
        payload.push_str(format!("<OtherMembers>{}</OtherMembers>", other_members).as_str());
        payload.push_str(format!("<CurrentURI>{}</CurrentURI>", current_uri).as_str());
        payload.push_str(format!("<CurrentURIMetaData>{}</CurrentURIMetaData>", current_urimeta_data).as_str());
        payload.push_str(format!("<SleepTimerState>{}</SleepTimerState>", sleep_timer_state).as_str());
        payload.push_str(format!("<AlarmState>{}</AlarmState>", alarm_state).as_str());
        payload.push_str(format!("<StreamRestartState>{}</StreamRestartState>", stream_restart_state).as_str());
        payload.push_str(format!("<CurrentAVTTrackList>{}</CurrentAVTTrackList>", current_avttrack_list).as_str());
        payload.push_str(format!("<CurrentQueueTrackList>{}</CurrentQueueTrackList>", current_queue_track_list).as_str());
        payload.push_str(format!("<CurrentSourceState>{}</CurrentSourceState>", current_source_state).as_str());
        payload.push_str(format!("<ResumePlayback>{}</ResumePlayback>", resume_playback).as_str());
        self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        Ok(())
    }

    /// ChangeCoordinator
    ///
    /// Parameters:
    /// * `instance_id` : InstanceID should always be `0`
    /// * `current_coordinator`
    /// * `new_coordinator`
    /// * `new_transport_settings`
    /// * `current_avtransport_uri`
    pub async fn change_coordinator(
            &self,
            instance_id: u32,
            current_coordinator: String,
            new_coordinator: String,
            new_transport_settings: String,
            current_avtransport_uri: String
        ) -> Result<(), Error> {
        // TODO: use xml helper
        let mut payload = String::new();
        payload.push_str(format!("<InstanceID>{}</InstanceID>", instance_id).as_str());
        payload.push_str(format!("<CurrentCoordinator>{}</CurrentCoordinator>", current_coordinator).as_str());
        payload.push_str(format!("<NewCoordinator>{}</NewCoordinator>", new_coordinator).as_str());
        payload.push_str(format!("<NewTransportSettings>{}</NewTransportSettings>", new_transport_settings).as_str());
        payload.push_str(format!("<CurrentAVTransportURI>{}</CurrentAVTransportURI>", current_avtransport_uri).as_str());
        self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        Ok(())
    }

    /// ChangeTransportSettings
    ///
    /// Parameters:
    /// * `instance_id` : InstanceID should always be `0`
    /// * `new_transport_settings`
    /// * `current_avtransport_uri`
    pub async fn change_transport_settings(
            &self,
            instance_id: u32,
            new_transport_settings: String,
            current_avtransport_uri: String
        ) -> Result<(), Error> {
        // TODO: use xml helper
        let mut payload = String::new();
        payload.push_str(format!("<InstanceID>{}</InstanceID>", instance_id).as_str());
        payload.push_str(format!("<NewTransportSettings>{}</NewTransportSettings>", new_transport_settings).as_str());
        payload.push_str(format!("<CurrentAVTransportURI>{}</CurrentAVTransportURI>", current_avtransport_uri).as_str());
        self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        Ok(())
    }

    /// ConfigureSleepTimer
    ///
    /// Stop playing after set sleep timer or cancel
    ///
    /// Note: Send to non-coordinator returns error code 800
    ///
    /// Parameters:
    /// * `instance_id` : InstanceID should always be `0`
    /// * `new_sleep_timer_duration` : Time to stop after, as `hh:mm:ss` or empty string to cancel
    pub async fn configure_sleep_timer(
            &self,
            instance_id: u32,
            new_sleep_timer_duration: String
        ) -> Result<(), Error> {
        // TODO: use xml helper
        let mut payload = String::new();
        payload.push_str(format!("<InstanceID>{}</InstanceID>", instance_id).as_str());
        payload.push_str(format!("<NewSleepTimerDuration>{}</NewSleepTimerDuration>", new_sleep_timer_duration).as_str());
        self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        Ok(())
    }

    /// CreateSavedQueue
    ///
    /// Parameters:
    /// * `instance_id` : InstanceID should always be `0`
    /// * `title`
    /// * `enqueued_uri`
    /// * `enqueued_urimeta_data`
    ///
    /// Outputs:
    /// * `num_tracks_added`
    /// * `new_queue_length`
    /// * `assigned_object_id`
    /// * `new_update_id`
    pub async fn create_saved_queue(
            &self,
            instance_id: u32,
            title: String,
            enqueued_uri: String,
            enqueued_urimeta_data: String
        ) -> Result<CreateSavedQueueResult, Error> {
        // TODO: use xml helper
        let mut payload = String::new();
        payload.push_str(format!("<InstanceID>{}</InstanceID>", instance_id).as_str());
        payload.push_str(format!("<Title>{}</Title>", title).as_str());
        payload.push_str(format!("<EnqueuedURI>{}</EnqueuedURI>", enqueued_uri).as_str());
        payload.push_str(format!("<EnqueuedURIMetaData>{}</EnqueuedURIMetaData>", enqueued_urimeta_data).as_str());
        let response = self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        // TODO: map parse errors
        Ok(CreateSavedQueueResult {
            num_tracks_added: response.get("NumTracksAdded").ok_or_else(|| Error::MissingField("NumTracksAdded".to_string()))?
                .parse().map_err(|_| Error::ParseError("NumTracksAdded".to_string()))?,
            new_queue_length: response.get("NewQueueLength").ok_or_else(|| Error::MissingField("NewQueueLength".to_string()))?
                .parse().map_err(|_| Error::ParseError("NewQueueLength".to_string()))?,
            assigned_object_id: response.get("AssignedObjectID").ok_or_else(|| Error::MissingField("AssignedObjectID".to_string()))?
                .parse().map_err(|_| Error::ParseError("AssignedObjectID".to_string()))?,
            new_update_id: response.get("NewUpdateID").ok_or_else(|| Error::MissingField("NewUpdateID".to_string()))?
                .parse().map_err(|_| Error::ParseError("NewUpdateID".to_string()))?,
        })
    }

    /// DelegateGroupCoordinationTo
    ///
    /// Delegates the coordinator role to another player in the same group
    ///
    /// Note: Send to non-coordinator has no results - should be avoided.
    ///
    /// Parameters:
    /// * `instance_id` : InstanceID should always be `0`
    /// * `new_coordinator` : uuid of the new coordinator - must be in same group
    /// * `rejoin_group` : Should former coordinator rejoin the group?
    pub async fn delegate_group_coordination_to(
            &self,
            instance_id: u32,
            new_coordinator: String,
            rejoin_group: bool
        ) -> Result<(), Error> {
        // TODO: use xml helper
        let mut payload = String::new();
        payload.push_str(format!("<InstanceID>{}</InstanceID>", instance_id).as_str());
        payload.push_str(format!("<NewCoordinator>{}</NewCoordinator>", new_coordinator).as_str());
        payload.push_str(format!("<RejoinGroup>{}</RejoinGroup>", rejoin_group).as_str());
        self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        Ok(())
    }

    /// EndDirectControlSession
    ///
    /// Parameters:
    /// * `instance_id` : InstanceID should always be `0`
    pub async fn end_direct_control_session(
            &self,
            instance_id: u32
        ) -> Result<(), Error> {
        // TODO: use xml helper
        let mut payload = String::new();
        payload.push_str(format!("<InstanceID>{}</InstanceID>", instance_id).as_str());
        self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        Ok(())
    }

    /// GetCrossfadeMode
    ///
    /// Get crossfade mode
    ///
    /// Note: Send to non-coordinator may return wrong value as only the coordinator value in a group
    ///
    /// Parameters:
    /// * `instance_id` : InstanceID should always be `0`
    ///
    /// Outputs:
    /// * `crossfade_mode`
    pub async fn get_crossfade_mode(
            &self,
            instance_id: u32
        ) -> Result<GetCrossfadeModeResult, Error> {
        // TODO: use xml helper
        let mut payload = String::new();
        payload.push_str(format!("<InstanceID>{}</InstanceID>", instance_id).as_str());
        let response = self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        // TODO: map parse errors
        Ok(GetCrossfadeModeResult {
            crossfade_mode: response.get("CrossfadeMode").ok_or_else(|| Error::MissingField("CrossfadeMode".to_string()))?
                .parse().map_err(|_| Error::ParseError("CrossfadeMode".to_string()))?,
        })
    }

    /// GetCurrentTransportActions
    ///
    /// Get current transport actions such as Set, Stop, Pause, Play, X_DLNA_SeekTime, Next, X_DLNA_SeekTrackNr
    ///
    /// Note: Send to non-coordinator returns only `Start` and `Stop` since it cannot control the stream.
    ///
    /// Parameters:
    /// * `instance_id` : InstanceID should always be `0`
    ///
    /// Outputs:
    /// * `actions`
    pub async fn get_current_transport_actions(
            &self,
            instance_id: u32
        ) -> Result<GetCurrentTransportActionsResult, Error> {
        // TODO: use xml helper
        let mut payload = String::new();
        payload.push_str(format!("<InstanceID>{}</InstanceID>", instance_id).as_str());
        let response = self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        // TODO: map parse errors
        Ok(GetCurrentTransportActionsResult {
            actions: response.get("Actions").ok_or_else(|| Error::MissingField("Actions".to_string()))?
                .parse().map_err(|_| Error::ParseError("Actions".to_string()))?,
        })
    }

    /// GetDeviceCapabilities
    ///
    /// Parameters:
    /// * `instance_id` : InstanceID should always be `0`
    ///
    /// Outputs:
    /// * `play_media`
    /// * `rec_media`
    /// * `rec_quality_modes`
    pub async fn get_device_capabilities(
            &self,
            instance_id: u32
        ) -> Result<GetDeviceCapabilitiesResult, Error> {
        // TODO: use xml helper
        let mut payload = String::new();
        payload.push_str(format!("<InstanceID>{}</InstanceID>", instance_id).as_str());
        let response = self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        // TODO: map parse errors
        Ok(GetDeviceCapabilitiesResult {
            play_media: response.get("PlayMedia").ok_or_else(|| Error::MissingField("PlayMedia".to_string()))?
                .parse().map_err(|_| Error::ParseError("PlayMedia".to_string()))?,
            rec_media: response.get("RecMedia").ok_or_else(|| Error::MissingField("RecMedia".to_string()))?
                .parse().map_err(|_| Error::ParseError("RecMedia".to_string()))?,
            rec_quality_modes: response.get("RecQualityModes").ok_or_else(|| Error::MissingField("RecQualityModes".to_string()))?
                .parse().map_err(|_| Error::ParseError("RecQualityModes".to_string()))?,
        })
    }

    /// GetMediaInfo
    ///
    /// Get information about the current playing media (queue)
    ///
    /// Parameters:
    /// * `instance_id` : InstanceID should always be `0`
    ///
    /// Outputs:
    /// * `nr_tracks`
    /// * `media_duration`
    /// * `current_uri`
    /// * `current_urimeta_data`
    /// * `next_uri`
    /// * `next_urimeta_data`
    /// * `play_medium`
    /// * `record_medium`
    /// * `write_status`
    pub async fn get_media_info(
            &self,
            instance_id: u32
        ) -> Result<GetMediaInfoResult, Error> {
        // TODO: use xml helper
        let mut payload = String::new();
        payload.push_str(format!("<InstanceID>{}</InstanceID>", instance_id).as_str());
        let response = self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        // TODO: map parse errors
        Ok(GetMediaInfoResult {
            nr_tracks: response.get("NrTracks").ok_or_else(|| Error::MissingField("NrTracks".to_string()))?
                .parse().map_err(|_| Error::ParseError("NrTracks".to_string()))?,
            media_duration: response.get("MediaDuration").ok_or_else(|| Error::MissingField("MediaDuration".to_string()))?
                .parse().map_err(|_| Error::ParseError("MediaDuration".to_string()))?,
            current_uri: response.get("CurrentURI").ok_or_else(|| Error::MissingField("CurrentURI".to_string()))?
                .parse().map_err(|_| Error::ParseError("CurrentURI".to_string()))?,
            current_urimeta_data: response.get("CurrentURIMetaData").ok_or_else(|| Error::MissingField("CurrentURIMetaData".to_string()))?
                .parse().map_err(|_| Error::ParseError("CurrentURIMetaData".to_string()))?,
            next_uri: response.get("NextURI").ok_or_else(|| Error::MissingField("NextURI".to_string()))?
                .parse().map_err(|_| Error::ParseError("NextURI".to_string()))?,
            next_urimeta_data: response.get("NextURIMetaData").ok_or_else(|| Error::MissingField("NextURIMetaData".to_string()))?
                .parse().map_err(|_| Error::ParseError("NextURIMetaData".to_string()))?,
            play_medium: response.get("PlayMedium").ok_or_else(|| Error::MissingField("PlayMedium".to_string()))?
                .parse().map_err(|_| Error::ParseError("PlayMedium".to_string()))?,
            record_medium: response.get("RecordMedium").ok_or_else(|| Error::MissingField("RecordMedium".to_string()))?
                .parse().map_err(|_| Error::ParseError("RecordMedium".to_string()))?,
            write_status: response.get("WriteStatus").ok_or_else(|| Error::MissingField("WriteStatus".to_string()))?
                .parse().map_err(|_| Error::ParseError("WriteStatus".to_string()))?,
        })
    }

    /// GetPositionInfo
    ///
    /// Get information about current position (position in queue and time in current song)
    ///
    /// Parameters:
    /// * `instance_id` : InstanceID should always be `0`
    ///
    /// Outputs:
    /// * `track`
    /// * `track_duration`
    /// * `track_meta_data`
    /// * `track_uri`
    /// * `rel_time`
    /// * `abs_time`
    /// * `rel_count`
    /// * `abs_count`
    pub async fn get_position_info(
            &self,
            instance_id: u32
        ) -> Result<GetPositionInfoResult, Error> {
        // TODO: use xml helper
        let mut payload = String::new();
        payload.push_str(format!("<InstanceID>{}</InstanceID>", instance_id).as_str());
        let response = self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        // TODO: map parse errors
        Ok(GetPositionInfoResult {
            track: response.get("Track").ok_or_else(|| Error::MissingField("Track".to_string()))?
                .parse().map_err(|_| Error::ParseError("Track".to_string()))?,
            track_duration: response.get("TrackDuration").ok_or_else(|| Error::MissingField("TrackDuration".to_string()))?
                .parse().map_err(|_| Error::ParseError("TrackDuration".to_string()))?,
            track_meta_data: response.get("TrackMetaData").ok_or_else(|| Error::MissingField("TrackMetaData".to_string()))?
                .parse().map_err(|_| Error::ParseError("TrackMetaData".to_string()))?,
            track_uri: response.get("TrackURI").ok_or_else(|| Error::MissingField("TrackURI".to_string()))?
                .parse().map_err(|_| Error::ParseError("TrackURI".to_string()))?,
            rel_time: response.get("RelTime").ok_or_else(|| Error::MissingField("RelTime".to_string()))?
                .parse().map_err(|_| Error::ParseError("RelTime".to_string()))?,
            abs_time: response.get("AbsTime").ok_or_else(|| Error::MissingField("AbsTime".to_string()))?
                .parse().map_err(|_| Error::ParseError("AbsTime".to_string()))?,
            rel_count: response.get("RelCount").ok_or_else(|| Error::MissingField("RelCount".to_string()))?
                .parse().map_err(|_| Error::ParseError("RelCount".to_string()))?,
            abs_count: response.get("AbsCount").ok_or_else(|| Error::MissingField("AbsCount".to_string()))?
                .parse().map_err(|_| Error::ParseError("AbsCount".to_string()))?,
        })
    }

    /// GetRemainingSleepTimerDuration
    ///
    /// Get time left on sleeptimer.
    ///
    /// Note: Send to non-coordinator returns error code 800
    ///
    /// Parameters:
    /// * `instance_id` : InstanceID should always be `0`
    ///
    /// Outputs:
    /// * `remaining_sleep_timer_duration` : Format hh:mm:ss or empty string if not set
    /// * `current_sleep_timer_generation`
    pub async fn get_remaining_sleep_timer_duration(
            &self,
            instance_id: u32
        ) -> Result<GetRemainingSleepTimerDurationResult, Error> {
        // TODO: use xml helper
        let mut payload = String::new();
        payload.push_str(format!("<InstanceID>{}</InstanceID>", instance_id).as_str());
        let response = self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        // TODO: map parse errors
        Ok(GetRemainingSleepTimerDurationResult {
            remaining_sleep_timer_duration: response.get("RemainingSleepTimerDuration").ok_or_else(|| Error::MissingField("RemainingSleepTimerDuration".to_string()))?
                .parse().map_err(|_| Error::ParseError("RemainingSleepTimerDuration".to_string()))?,
            current_sleep_timer_generation: response.get("CurrentSleepTimerGeneration").ok_or_else(|| Error::MissingField("CurrentSleepTimerGeneration".to_string()))?
                .parse().map_err(|_| Error::ParseError("CurrentSleepTimerGeneration".to_string()))?,
        })
    }

    /// GetRunningAlarmProperties
    ///
    /// Parameters:
    /// * `instance_id` : InstanceID should always be `0`
    ///
    /// Outputs:
    /// * `alarm_id`
    /// * `group_id`
    /// * `logged_start_time`
    pub async fn get_running_alarm_properties(
            &self,
            instance_id: u32
        ) -> Result<GetRunningAlarmPropertiesResult, Error> {
        // TODO: use xml helper
        let mut payload = String::new();
        payload.push_str(format!("<InstanceID>{}</InstanceID>", instance_id).as_str());
        let response = self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        // TODO: map parse errors
        Ok(GetRunningAlarmPropertiesResult {
            alarm_id: response.get("AlarmID").ok_or_else(|| Error::MissingField("AlarmID".to_string()))?
                .parse().map_err(|_| Error::ParseError("AlarmID".to_string()))?,
            group_id: response.get("GroupID").ok_or_else(|| Error::MissingField("GroupID".to_string()))?
                .parse().map_err(|_| Error::ParseError("GroupID".to_string()))?,
            logged_start_time: response.get("LoggedStartTime").ok_or_else(|| Error::MissingField("LoggedStartTime".to_string()))?
                .parse().map_err(|_| Error::ParseError("LoggedStartTime".to_string()))?,
        })
    }

    /// GetTransportInfo
    ///
    /// Get current transport status, speed and state such as PLAYING, STOPPED, PLAYING, PAUSED_PLAYBACK, TRANSITIONING, NO_MEDIA_PRESENT
    ///
    /// Note: Send to non-coordinator always returns PLAYING
    ///
    /// Parameters:
    /// * `instance_id` : InstanceID should always be `0`
    ///
    /// Outputs:
    /// * `current_transport_state`
    /// * `current_transport_status`
    /// * `current_speed`
    pub async fn get_transport_info(
            &self,
            instance_id: u32
        ) -> Result<GetTransportInfoResult, Error> {
        // TODO: use xml helper
        let mut payload = String::new();
        payload.push_str(format!("<InstanceID>{}</InstanceID>", instance_id).as_str());
        let response = self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        // TODO: map parse errors
        Ok(GetTransportInfoResult {
            current_transport_state: response.get("CurrentTransportState").ok_or_else(|| Error::MissingField("CurrentTransportState".to_string()))?
                .parse().map_err(|_| Error::ParseError("CurrentTransportState".to_string()))?,
            current_transport_status: response.get("CurrentTransportStatus").ok_or_else(|| Error::MissingField("CurrentTransportStatus".to_string()))?
                .parse().map_err(|_| Error::ParseError("CurrentTransportStatus".to_string()))?,
            current_speed: response.get("CurrentSpeed").ok_or_else(|| Error::MissingField("CurrentSpeed".to_string()))?
                .parse().map_err(|_| Error::ParseError("CurrentSpeed".to_string()))?,
        })
    }

    /// GetTransportSettings
    ///
    /// Get transport settings
    ///
    /// Note: Send to non-coordinator returns the settings of it's queue
    ///
    /// Parameters:
    /// * `instance_id` : InstanceID should always be `0`
    ///
    /// Outputs:
    /// * `play_mode`
    /// * `rec_quality_mode`
    pub async fn get_transport_settings(
            &self,
            instance_id: u32
        ) -> Result<GetTransportSettingsResult, Error> {
        // TODO: use xml helper
        let mut payload = String::new();
        payload.push_str(format!("<InstanceID>{}</InstanceID>", instance_id).as_str());
        let response = self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        // TODO: map parse errors
        Ok(GetTransportSettingsResult {
            play_mode: response.get("PlayMode").ok_or_else(|| Error::MissingField("PlayMode".to_string()))?
                .parse().map_err(|_| Error::ParseError("PlayMode".to_string()))?,
            rec_quality_mode: response.get("RecQualityMode").ok_or_else(|| Error::MissingField("RecQualityMode".to_string()))?
                .parse().map_err(|_| Error::ParseError("RecQualityMode".to_string()))?,
        })
    }

    /// Next
    ///
    /// Go to next song
    ///
    /// Note: Possibly not supported at the moment see GetCurrentTransportActions
    ///
    /// Parameters:
    /// * `instance_id` : InstanceID should always be `0`
    pub async fn next(
            &self,
            instance_id: u32
        ) -> Result<(), Error> {
        // TODO: use xml helper
        let mut payload = String::new();
        payload.push_str(format!("<InstanceID>{}</InstanceID>", instance_id).as_str());
        self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        Ok(())
    }

    /// NotifyDeletedURI
    ///
    /// Parameters:
    /// * `instance_id` : InstanceID should always be `0`
    /// * `deleted_uri`
    pub async fn notify_deleted_uri(
            &self,
            instance_id: u32,
            deleted_uri: String
        ) -> Result<(), Error> {
        // TODO: use xml helper
        let mut payload = String::new();
        payload.push_str(format!("<InstanceID>{}</InstanceID>", instance_id).as_str());
        payload.push_str(format!("<DeletedURI>{}</DeletedURI>", deleted_uri).as_str());
        self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        Ok(())
    }

    /// Pause
    ///
    /// Pause playback
    ///
    /// Parameters:
    /// * `instance_id` : InstanceID should always be `0`
    pub async fn pause(
            &self,
            instance_id: u32
        ) -> Result<(), Error> {
        // TODO: use xml helper
        let mut payload = String::new();
        payload.push_str(format!("<InstanceID>{}</InstanceID>", instance_id).as_str());
        self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        Ok(())
    }

    /// Play
    ///
    /// Start playing the set TransportURI
    ///
    /// Parameters:
    /// * `instance_id` : InstanceID should always be `0`
    /// * `speed` : Play speed usually 1, can be a fraction of 1
    pub async fn play(
            &self,
            instance_id: u32,
            speed: String
        ) -> Result<(), Error> {
        // TODO: use xml helper
        let mut payload = String::new();
        payload.push_str(format!("<InstanceID>{}</InstanceID>", instance_id).as_str());
        payload.push_str(format!("<Speed>{}</Speed>", speed).as_str());
        self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        Ok(())
    }

    /// Previous
    ///
    /// Go to previous song
    ///
    /// Note: Possibly not supported at the moment see GetCurrentTransportActions
    ///
    /// Parameters:
    /// * `instance_id` : InstanceID should always be `0`
    pub async fn previous(
            &self,
            instance_id: u32
        ) -> Result<(), Error> {
        // TODO: use xml helper
        let mut payload = String::new();
        payload.push_str(format!("<InstanceID>{}</InstanceID>", instance_id).as_str());
        self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        Ok(())
    }

    /// RemoveAllTracksFromQueue
    ///
    /// Flushes the SONOS queue.
    ///
    /// Note: If queue is already empty it throw error 804. Send to non-coordinator returns error code 800.
    ///
    /// Parameters:
    /// * `instance_id` : InstanceID should always be `0`
    pub async fn remove_all_tracks_from_queue(
            &self,
            instance_id: u32
        ) -> Result<(), Error> {
        // TODO: use xml helper
        let mut payload = String::new();
        payload.push_str(format!("<InstanceID>{}</InstanceID>", instance_id).as_str());
        self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        Ok(())
    }

    /// RemoveTrackFromQueue
    ///
    /// Parameters:
    /// * `instance_id` : InstanceID should always be `0`
    /// * `object_id`
    /// * `update_id`
    pub async fn remove_track_from_queue(
            &self,
            instance_id: u32,
            object_id: String,
            update_id: u32
        ) -> Result<(), Error> {
        // TODO: use xml helper
        let mut payload = String::new();
        payload.push_str(format!("<InstanceID>{}</InstanceID>", instance_id).as_str());
        payload.push_str(format!("<ObjectID>{}</ObjectID>", object_id).as_str());
        payload.push_str(format!("<UpdateID>{}</UpdateID>", update_id).as_str());
        self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        Ok(())
    }

    /// RemoveTrackRangeFromQueue
    ///
    /// Removes the specified range of songs from the SONOS queue.
    ///
    /// Parameters:
    /// * `instance_id` : InstanceID should always be `0`
    /// * `update_id` : Leave blank
    /// * `starting_index` : between 1 and queue-length
    /// * `number_of_tracks`
    ///
    /// Outputs:
    /// * `new_update_id`
    pub async fn remove_track_range_from_queue(
            &self,
            instance_id: u32,
            update_id: u32,
            starting_index: u32,
            number_of_tracks: u32
        ) -> Result<RemoveTrackRangeFromQueueResult, Error> {
        // TODO: use xml helper
        let mut payload = String::new();
        payload.push_str(format!("<InstanceID>{}</InstanceID>", instance_id).as_str());
        payload.push_str(format!("<UpdateID>{}</UpdateID>", update_id).as_str());
        payload.push_str(format!("<StartingIndex>{}</StartingIndex>", starting_index).as_str());
        payload.push_str(format!("<NumberOfTracks>{}</NumberOfTracks>", number_of_tracks).as_str());
        let response = self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        // TODO: map parse errors
        Ok(RemoveTrackRangeFromQueueResult {
            new_update_id: response.get("NewUpdateID").ok_or_else(|| Error::MissingField("NewUpdateID".to_string()))?
                .parse().map_err(|_| Error::ParseError("NewUpdateID".to_string()))?,
        })
    }

    /// ReorderTracksInQueue
    ///
    /// Parameters:
    /// * `instance_id` : InstanceID should always be `0`
    /// * `starting_index`
    /// * `number_of_tracks`
    /// * `insert_before`
    /// * `update_id`
    pub async fn reorder_tracks_in_queue(
            &self,
            instance_id: u32,
            starting_index: u32,
            number_of_tracks: u32,
            insert_before: u32,
            update_id: u32
        ) -> Result<(), Error> {
        // TODO: use xml helper
        let mut payload = String::new();
        payload.push_str(format!("<InstanceID>{}</InstanceID>", instance_id).as_str());
        payload.push_str(format!("<StartingIndex>{}</StartingIndex>", starting_index).as_str());
        payload.push_str(format!("<NumberOfTracks>{}</NumberOfTracks>", number_of_tracks).as_str());
        payload.push_str(format!("<InsertBefore>{}</InsertBefore>", insert_before).as_str());
        payload.push_str(format!("<UpdateID>{}</UpdateID>", update_id).as_str());
        self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        Ok(())
    }

    /// ReorderTracksInSavedQueue
    ///
    /// Parameters:
    /// * `instance_id` : InstanceID should always be `0`
    /// * `object_id`
    /// * `update_id`
    /// * `track_list`
    /// * `new_position_list`
    ///
    /// Outputs:
    /// * `queue_length_change`
    /// * `new_queue_length`
    /// * `new_update_id`
    pub async fn reorder_tracks_in_saved_queue(
            &self,
            instance_id: u32,
            object_id: String,
            update_id: u32,
            track_list: String,
            new_position_list: String
        ) -> Result<ReorderTracksInSavedQueueResult, Error> {
        // TODO: use xml helper
        let mut payload = String::new();
        payload.push_str(format!("<InstanceID>{}</InstanceID>", instance_id).as_str());
        payload.push_str(format!("<ObjectID>{}</ObjectID>", object_id).as_str());
        payload.push_str(format!("<UpdateID>{}</UpdateID>", update_id).as_str());
        payload.push_str(format!("<TrackList>{}</TrackList>", track_list).as_str());
        payload.push_str(format!("<NewPositionList>{}</NewPositionList>", new_position_list).as_str());
        let response = self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        // TODO: map parse errors
        Ok(ReorderTracksInSavedQueueResult {
            queue_length_change: response.get("QueueLengthChange").ok_or_else(|| Error::MissingField("QueueLengthChange".to_string()))?
                .parse().map_err(|_| Error::ParseError("QueueLengthChange".to_string()))?,
            new_queue_length: response.get("NewQueueLength").ok_or_else(|| Error::MissingField("NewQueueLength".to_string()))?
                .parse().map_err(|_| Error::ParseError("NewQueueLength".to_string()))?,
            new_update_id: response.get("NewUpdateID").ok_or_else(|| Error::MissingField("NewUpdateID".to_string()))?
                .parse().map_err(|_| Error::ParseError("NewUpdateID".to_string()))?,
        })
    }

    /// RunAlarm
    ///
    /// Parameters:
    /// * `instance_id` : InstanceID should always be `0`
    /// * `alarm_id`
    /// * `logged_start_time`
    /// * `duration`
    /// * `program_uri`
    /// * `program_meta_data`
    /// * `play_mode`
    /// * `volume`
    /// * `include_linked_zones`
    pub async fn run_alarm(
            &self,
            instance_id: u32,
            alarm_id: u32,
            logged_start_time: String,
            duration: String,
            program_uri: String,
            program_meta_data: String,
            play_mode: String,
            volume: u16,
            include_linked_zones: bool
        ) -> Result<(), Error> {
        // TODO: use xml helper
        let mut payload = String::new();
        payload.push_str(format!("<InstanceID>{}</InstanceID>", instance_id).as_str());
        payload.push_str(format!("<AlarmID>{}</AlarmID>", alarm_id).as_str());
        payload.push_str(format!("<LoggedStartTime>{}</LoggedStartTime>", logged_start_time).as_str());
        payload.push_str(format!("<Duration>{}</Duration>", duration).as_str());
        payload.push_str(format!("<ProgramURI>{}</ProgramURI>", program_uri).as_str());
        payload.push_str(format!("<ProgramMetaData>{}</ProgramMetaData>", program_meta_data).as_str());
        payload.push_str(format!("<PlayMode>{}</PlayMode>", play_mode).as_str());
        payload.push_str(format!("<Volume>{}</Volume>", volume).as_str());
        payload.push_str(format!("<IncludeLinkedZones>{}</IncludeLinkedZones>", include_linked_zones).as_str());
        self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        Ok(())
    }

    /// SaveQueue
    ///
    /// Saves the current SONOS queue as a SONOS playlist and outputs objectID
    ///
    /// Note: Send to non-coordinator returns error code 800
    ///
    /// Parameters:
    /// * `instance_id` : InstanceID should always be `0`
    /// * `title` : SONOS playlist title
    /// * `object_id` : Leave blank
    ///
    /// Outputs:
    /// * `assigned_object_id`
    pub async fn save_queue(
            &self,
            instance_id: u32,
            title: String,
            object_id: String
        ) -> Result<SaveQueueResult, Error> {
        // TODO: use xml helper
        let mut payload = String::new();
        payload.push_str(format!("<InstanceID>{}</InstanceID>", instance_id).as_str());
        payload.push_str(format!("<Title>{}</Title>", title).as_str());
        payload.push_str(format!("<ObjectID>{}</ObjectID>", object_id).as_str());
        let response = self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        // TODO: map parse errors
        Ok(SaveQueueResult {
            assigned_object_id: response.get("AssignedObjectID").ok_or_else(|| Error::MissingField("AssignedObjectID".to_string()))?
                .parse().map_err(|_| Error::ParseError("AssignedObjectID".to_string()))?,
        })
    }

    /// Seek
    ///
    /// Seek track in queue, time delta or absolute time in song
    ///
    /// Note: Returns error code 701 in case that content does not support Seek or send to non-coordinator
    ///
    /// Parameters:
    /// * `instance_id` : InstanceID should always be `0`
    /// * `unit` : What to seek
    /// * `target` : Position of track in queue (start at 1) or `hh:mm:ss` for `REL_TIME` or `+/-hh:mm:ss` for `TIME_DELTA`
    pub async fn seek(
            &self,
            instance_id: u32,
            unit: String,
            target: String
        ) -> Result<(), Error> {
        // TODO: use xml helper
        let mut payload = String::new();
        payload.push_str(format!("<InstanceID>{}</InstanceID>", instance_id).as_str());
        payload.push_str(format!("<Unit>{}</Unit>", unit).as_str());
        payload.push_str(format!("<Target>{}</Target>", target).as_str());
        self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        Ok(())
    }

    /// SetAVTransportURI
    ///
    /// Set the transport URI to a song, a stream, the queue, another player-rincon and a lot more
    ///
    /// Note: If set to another player RINCON, the player is grouped with that one.
    ///
    /// Parameters:
    /// * `instance_id` : InstanceID should always be `0`
    /// * `current_uri` : The new TransportURI - its a special SONOS format
    /// * `current_urimeta_data` : Track Metadata, see MetadataHelper.GuessTrack to guess based on track uri
    pub async fn set_avtransport_uri(
            &self,
            instance_id: u32,
            current_uri: String,
            current_urimeta_data: String
        ) -> Result<(), Error> {
        // TODO: use xml helper
        let mut payload = String::new();
        payload.push_str(format!("<InstanceID>{}</InstanceID>", instance_id).as_str());
        payload.push_str(format!("<CurrentURI>{}</CurrentURI>", current_uri).as_str());
        payload.push_str(format!("<CurrentURIMetaData>{}</CurrentURIMetaData>", current_urimeta_data).as_str());
        self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        Ok(())
    }

    /// SetCrossfadeMode
    ///
    /// Set crossfade mode
    ///
    /// Note: Send to non-coordinator returns error code 800. Same for content, which does not support crossfade mode.
    ///
    /// Parameters:
    /// * `instance_id` : InstanceID should always be `0`
    /// * `crossfade_mode`
    pub async fn set_crossfade_mode(
            &self,
            instance_id: u32,
            crossfade_mode: bool
        ) -> Result<(), Error> {
        // TODO: use xml helper
        let mut payload = String::new();
        payload.push_str(format!("<InstanceID>{}</InstanceID>", instance_id).as_str());
        payload.push_str(format!("<CrossfadeMode>{}</CrossfadeMode>", crossfade_mode).as_str());
        self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        Ok(())
    }

    /// SetNextAVTransportURI
    ///
    /// Parameters:
    /// * `instance_id` : InstanceID should always be `0`
    /// * `next_uri`
    /// * `next_urimeta_data`
    pub async fn set_next_avtransport_uri(
            &self,
            instance_id: u32,
            next_uri: String,
            next_urimeta_data: String
        ) -> Result<(), Error> {
        // TODO: use xml helper
        let mut payload = String::new();
        payload.push_str(format!("<InstanceID>{}</InstanceID>", instance_id).as_str());
        payload.push_str(format!("<NextURI>{}</NextURI>", next_uri).as_str());
        payload.push_str(format!("<NextURIMetaData>{}</NextURIMetaData>", next_urimeta_data).as_str());
        self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        Ok(())
    }

    /// SetPlayMode
    ///
    /// Set the PlayMode
    ///
    /// Note: Send to non-coordinator returns error code 712. If SONOS queue is not activated returns error code 712.
    ///
    /// Parameters:
    /// * `instance_id` : InstanceID should always be `0`
    /// * `new_play_mode` : New playmode
    pub async fn set_play_mode(
            &self,
            instance_id: u32,
            new_play_mode: String
        ) -> Result<(), Error> {
        // TODO: use xml helper
        let mut payload = String::new();
        payload.push_str(format!("<InstanceID>{}</InstanceID>", instance_id).as_str());
        payload.push_str(format!("<NewPlayMode>{}</NewPlayMode>", new_play_mode).as_str());
        self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        Ok(())
    }

    /// SnoozeAlarm
    ///
    /// Snooze the current alarm for some time.
    ///
    /// Parameters:
    /// * `instance_id` : InstanceID should always be `0`
    /// * `duration` : Snooze time as `hh:mm:ss`, 10 minutes = 00:10:00
    pub async fn snooze_alarm(
            &self,
            instance_id: u32,
            duration: String
        ) -> Result<(), Error> {
        // TODO: use xml helper
        let mut payload = String::new();
        payload.push_str(format!("<InstanceID>{}</InstanceID>", instance_id).as_str());
        payload.push_str(format!("<Duration>{}</Duration>", duration).as_str());
        self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        Ok(())
    }

    /// StartAutoplay
    ///
    /// Parameters:
    /// * `instance_id` : InstanceID should always be `0`
    /// * `program_uri`
    /// * `program_meta_data`
    /// * `volume`
    /// * `include_linked_zones`
    /// * `reset_volume_after`
    pub async fn start_autoplay(
            &self,
            instance_id: u32,
            program_uri: String,
            program_meta_data: String,
            volume: u16,
            include_linked_zones: bool,
            reset_volume_after: bool
        ) -> Result<(), Error> {
        // TODO: use xml helper
        let mut payload = String::new();
        payload.push_str(format!("<InstanceID>{}</InstanceID>", instance_id).as_str());
        payload.push_str(format!("<ProgramURI>{}</ProgramURI>", program_uri).as_str());
        payload.push_str(format!("<ProgramMetaData>{}</ProgramMetaData>", program_meta_data).as_str());
        payload.push_str(format!("<Volume>{}</Volume>", volume).as_str());
        payload.push_str(format!("<IncludeLinkedZones>{}</IncludeLinkedZones>", include_linked_zones).as_str());
        payload.push_str(format!("<ResetVolumeAfter>{}</ResetVolumeAfter>", reset_volume_after).as_str());
        self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        Ok(())
    }

    /// Stop
    ///
    /// Stop playback
    ///
    /// Parameters:
    /// * `instance_id` : InstanceID should always be `0`
    pub async fn stop(
            &self,
            instance_id: u32
        ) -> Result<(), Error> {
        // TODO: use xml helper
        let mut payload = String::new();
        payload.push_str(format!("<InstanceID>{}</InstanceID>", instance_id).as_str());
        self.service.action(&self.url, "SetTimeNow", payload.as_str()).await?;
        Ok(())
    }
}

#[derive(Debug)]
pub struct AddMultipleURIsToQueueResult {
    pub first_track_number_enqueued: u32,
    pub num_tracks_added: u32,
    pub new_queue_length: u32,
    pub new_update_id: u32,
}

#[derive(Debug)]
pub struct AddURIToQueueResult {
    pub first_track_number_enqueued: u32,
    pub num_tracks_added: u32,
    pub new_queue_length: u32,
}

#[derive(Debug)]
pub struct AddURIToSavedQueueResult {
    pub num_tracks_added: u32,
    pub new_queue_length: u32,
    pub new_update_id: u32,
}

#[derive(Debug)]
pub struct BecomeCoordinatorOfStandaloneGroupResult {
    pub delegated_group_coordinator_id: String,
    pub new_group_id: String,
}

#[derive(Debug)]
pub struct CreateSavedQueueResult {
    pub num_tracks_added: u32,
    pub new_queue_length: u32,
    pub assigned_object_id: String,
    pub new_update_id: u32,
}

#[derive(Debug)]
pub struct GetCrossfadeModeResult {
    pub crossfade_mode: bool,
}

#[derive(Debug)]
pub struct GetCurrentTransportActionsResult {
    pub actions: String,
}

#[derive(Debug)]
pub struct GetDeviceCapabilitiesResult {
    pub play_media: String,
    pub rec_media: String,
    pub rec_quality_modes: String,
}

#[derive(Debug)]
pub struct GetMediaInfoResult {
    pub nr_tracks: u32,
    pub media_duration: String,
    pub current_uri: String,
    pub current_urimeta_data: String,
    pub next_uri: String,
    pub next_urimeta_data: String,
    pub play_medium: String,
    pub record_medium: String,
    pub write_status: String,
}

#[derive(Debug)]
pub struct GetPositionInfoResult {
    pub track: u32,
    pub track_duration: String,
    pub track_meta_data: String,
    pub track_uri: String,
    pub rel_time: String,
    pub abs_time: String,
    pub rel_count: i32,
    pub abs_count: i32,
}

#[derive(Debug)]
pub struct GetRemainingSleepTimerDurationResult {
    /// Format hh:mm:ss or empty string if not set
    pub remaining_sleep_timer_duration: String,
    pub current_sleep_timer_generation: u32,
}

#[derive(Debug)]
pub struct GetRunningAlarmPropertiesResult {
    pub alarm_id: u32,
    pub group_id: String,
    pub logged_start_time: String,
}

#[derive(Debug)]
pub struct GetTransportInfoResult {
    pub current_transport_state: String,
    pub current_transport_status: String,
    pub current_speed: String,
}

#[derive(Debug)]
pub struct GetTransportSettingsResult {
    pub play_mode: String,
    pub rec_quality_mode: String,
}

#[derive(Debug)]
pub struct RemoveTrackRangeFromQueueResult {
    pub new_update_id: u32,
}

#[derive(Debug)]
pub struct ReorderTracksInSavedQueueResult {
    pub queue_length_change: i32,
    pub new_queue_length: u32,
    pub new_update_id: u32,
}

#[derive(Debug)]
pub struct SaveQueueResult {
    pub assigned_object_id: String,
}

